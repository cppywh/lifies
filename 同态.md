# 同态加密

## **入门**

### 格

#### 定义

设$v_1,v_2,...,v_n ∈ R^m $为一组线性无关的向量。由这些向量生成的**格$L$**指的是**向量的线性组合构成的向量集合**，**且其所有的系数均在$ \mathbb{Z}$ (整数)中**，即：
$$
$L = \{ a_1 \mathbf{v}_1 + a_2 \mathbf{v}_2 + \cdots + a_n \mathbf{v}_n : a_1, a_2, \cdots, a_n \in \mathbb{Z}, \mathbf{v}_1, \mathbf{v}_2, \cdots, \mathbf{v}_n \in \mathbb{R}^m \}.$
$$
这些basis向量加上整数系数构成的所有**点就是格**

任意一组可以生成格的**线性无关的向量**称为格的**基**，格基的**向量个数**称为格的**维度**。

###### 格的行列式：det（L）

几何意义vol（F）（是F的体积）：“基本平行多面体” 的‘体积’，比如二维就是平行四边形，也是个基础区域 F，三维平行六面体。

格的行列式是**格的不变量**—— 无论选择格的哪一组基（同一格可以有无数组不同的基），计算出的行列式结果都相同。

与格的 “疏密” 关系：行列式越小，格越密集

###### Hadamard 不等式

L是一个格，任意一个基和基础区域 F ，有

det L = vol（F）≤ || v1|| || v2|| .....|| vm|| ，基向量范数的积

越接近垂直，等式越成立

###### dim（L）

格的维度，即格的基中的向量个数

###### Hadamard比率

用于描述一组向量的正交程度

0< H（B）≤1，且越接近1，则基中的向量就越接近两两正交
$$
\
\mathcal{H}(B) = \left( \frac{\det L}{\prod_{i=1}^n \|\mathbf{v}_i\|} \right)^{1/n}
$$


#### 优质基与劣质基

• **优质基：**向量角度比较大（Hadamard 比率较大，接近 1）。使用优质基，调用 Babai 算法，**能**在多项式时间内求解 CVP 困难问题；

• **劣质基：**向量角度比较小（Hadamard 比率较小，接近 0）。使用劣质基，**不能**在多项式时间内求解 CVP困难问题

##### **格基相互转化**

已知优质基 \( \mathbf{V} = (\mathbf{v}_1, \dots, \mathbf{v}_n) \)，能在**多项式时间**内求劣质基 \( \mathbf{W} = (\mathbf{w}_1, \dots, \mathbf{w}_n) \)。 

**求解方法：**选择幺模矩阵 \( \mathbf{A} \)，即 \( \det(\mathbf{A}) = \pm 1 \)，则 \[ \mathbf{W} := \mathbf{A}\mathbf{V} \] 。

反之，已知劣质基 \( \mathbf{W} \)，不能在多项式时间内求优质基 \( \mathbf{V} \)。

#### 格中困难问题

• **最短向量问题** **(SVP,Shortest Vector Problem):**在格 L 中求一个非零向量 v∈L使它的欧几里得范数 ||v|| 最小。

• **SVP** **问题困难性：**已知劣质基，求优质基；然后枚举零点附近的格点；最后找到最短向量。

• **最近向量问题** **(CVP,Closest):** 已知一个不在格 L 中的向量 w ∈ $R^m$，求一个向量 v∈L，使它最接近 w。换言之，求一个向量 v∈L，使欧几里得范数 ||w−v|| 最小。

• **CVP** **问题困难性：**已知劣质基，需要使用劣质基枚举所有格点；然后计算每个格点与目标点的距离；最后筛选法找出最短距离。

在格中可能存在不止一个最短的非零向量（找出一个即可）。例如，在 $\mathbb{Z}^2$ 中，(0, ±1) 和 (±1, 0) 这四个向量都是 SVP 解。这种情形也适用于 CVP。

随着格的维度 n 的增加，在计算上也越来越难解。另外，即使是对 SVP 和 CVP 的近似解，在理论和应用数学的诸多领域都有许多应用。通常，CVP 被认为是 NP 难问题，SVP 在特定的“随机规约假设”下也被认为是 NP 难问题。

(NP问题是指一个问题可以在多项式时间内**验证**其解是否正确，但不一定能在多项式时间内**求解**。它的英文全称为 "Non-deterministic Polynomial"（非确定性多项式）)

**最短基问题**留坑

**近似最短/最近向量问题**留坑

#### Babai 算法

已知**优质基** $V = (v_1, ..., v_n)$，求目标向量 w 的最近向量 w′，即解决 CVP 困难问题。

Babai 算法 \(\mathbf{w}' = \left\lfloor \mathbf{w} \mathbf{V}^{-1} \right\rfloor \mathbf{V}\)。具体而言，包括以下三个步骤：

1. 使用优质基，能在多项式时间内解方程组，求出实数 \(t_i \in \mathbb{R}\)，使得 \(\mathbf{w} = t_1\mathbf{v}_1 + \dots + t_n\mathbf{v}_n\)，即任意向量由基线性表达。
2. 对于实数 \(t_i \in \mathbb{R}\)，取四舍五入【去噪声】\(a_i = \left\lfloor t_i \right\rceil\)（最近整数取整）。
3. 计算向量 \(\mathbf{w}' := a_1\mathbf{v}_1 + \dots + a_n\mathbf{v}_n\)，则 \(\mathbf{w}'\) 是 \(\mathbf{w}\) 的最近向量

使用**劣质基**时，$t_i$四舍五入的误差较大，无法获得正确结果。

如果目标向量 w 是一个**噪声**（欧几里得范数很小），则 $t_i$ 非常接近 0，四舍五入后获得的 $a_i$ 等于 0，去噪。

因此，Babai 算法输入**优质基**，去噪声，误差小，能找到最近向量，**解决 CVP 困难问题**。
反之，Babai 算法输入劣质基，去噪声，误差大，不能找到最近向量，不能解决 CVP 困难问题。

栗子：

- 已知最优质基 \(\begin{pmatrix} 10 \\ 0 \end{pmatrix}\)、\(\begin{pmatrix} 0 \\ 10 \end{pmatrix}\) 和目标向量（格点 + 噪声）\(\mathbf{w} = \begin{pmatrix} 12 \\ -13 \end{pmatrix}\)，求出 \(t_1 = 1.2\)，\(t_2 = -1.3\)，则 \(a_1 = 1\)，\(a_2 = -1\)，则最近向量 \(\mathbf{w}' = \begin{pmatrix} 10 \\ -10 \end{pmatrix}\)，去噪声，找到目标向量。

注意如果噪声过大，就会导致四舍五入出现非预期结果

噪声 \(\mathbf{r}\) 的范数需满足：

\(\|\mathbf{r}\| < \frac{1}{2} \cdot \min\left\{ \|\mathbf{v}_i\| \cdot \text{Hadamard比率} \right\}\)

- \(\|\mathbf{v}_i\|\) 是优质基向量的长度；

#### LWE 困难问题

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251117214414225.png" alt="image-20251117214414225" style="zoom:50%;" />

- **LWE 搜索困难问题**：已知矩阵 \(\mathbf{A} \in \mathbb{Z}_q^{m \times n}\) 和向量 \(\mathbf{b} \in \mathbb{Z}_q^m\)，求向量 \(\mathbf{s} \in \mathbb{Z}_q^n\) 是困难的。其中，

  \(\mathbf{b} = \mathbf{A}\mathbf{s} + \mathbf{e} \mod q\)

  \(\mathbf{e} \in \mathbb{Z}_N^m\) 是噪声（欧几里得范数很小）。

- **LWE 判决困难问题**：已知矩阵 \(\mathbf{A} \in \mathbb{Z}_q^{m \times n}\) 和向量 \(\mathbf{b} \in \mathbb{Z}_q^m\)，判断是 LWE 实例，还是随机数实例。（无法区分）

Regev 在 2005 年研究了 LWE 问题的困难性，证明在量子归约下，LWE 至少与 worst-case 的近似因子为 \(\tilde{O}(n/\alpha)\) 的 SVP 的变体一样困难。其中，\(\alpha\) 是 LWE 实例中与扰动分布的方差有关的参数。[On lattices, learning with errors, random linear codes, and cryptography](https://eprint.iacr.org/2005/265.pdf)

#### 环 LWE 困难问题

模 \(q \geq 2\)，多项式次数 \(n \geq 1\) 是 2 的幂次方，多项式为 \(f(x) = x^n + 1\)。环 \(R = \mathbb{Z}[x]/(f(x))\)，环 \(R_q = \mathbb{Z}_q[x]/(f(x))\)。\(\chi\) 是 R 上的一个噪声概率分布。\(\bar{A}_{s,\chi}\) 是 \(R_q \times R_q\) 上的一个概率分布。该分布以如下方式获得：随机选择 \(\mathbf{a} \in R_q\)，根据分布 \(\chi\) 选择噪声向量 \(\mathbf{e} \in R_q\)，则

\(\bar{A}_{s,\chi} = (\mathbf{a}, \mathbf{b}) = (\mathbf{a}, \mathbf{a} \cdot \mathbf{s} + \mathbf{e}) \in R_q \times R_q\)     

（$\bar{A}_{s,\chi}$上面的**横杠**是一种**标记约定**，用于表示这是一个**概率分布**）

- **环 LWE 搜索困难问题**：已知 \((\mathbf{a}, \mathbf{b}) \in R_q \times R_q\)，求 \(\mathbf{s} \in R_q\) 是困难的。
- **环 LWE 判决困难问题**：已知环 LWE \((\mathbf{a}, \mathbf{b}) \in R_q \times R_q\) 实例与随机均匀分布实例 \((\mathbf{a}', \mathbf{b}')\)，无法区分。

#### GGH 公钥密码系统

[Public-key cryptosystems from lattice reduction problems][https://link.springer.com/chapter/10.1007/BFb0052231]

- **密钥生成**：选择一个优质基 \( \mathbf{V} = (\mathbf{v}_1, \dots, \mathbf{v}_n) \) 作为私钥sk。选择一个整数幺模矩阵 \(\mathbf{U}\)，即 \(\det(\mathbf{U}) = \pm 1\)。计算 \(\mathbf{W} := \mathbf{U}\mathbf{V}\)，则获得劣质基 \( \mathbf{W} = (\mathbf{w}_1, \dots, \mathbf{w}_n) \) 作为公钥pk。

- **加密**：消息为小向量 \(\mathbf{m}\)，选择噪声 \(\mathbf{r}\)，输入公钥 \( \mathbf{W} \)，如下计算：

  \(\mathbf{c} = \mathbf{m} \cdot \mathbf{W} + \mathbf{r}\)

  则密文为 \(\mathbf{c}\)。

- **解密**：调用 Babai 算法，输入私钥（优质基 \( \mathbf{V} \)），如下解密：

  \(\begin{align*}  [\mathbf{c}\mathbf{V}^{-1}] \cdot \mathbf{V}\mathbf{W}^{-1} &= [(\mathbf{m} \cdot \mathbf{W} + \mathbf{r})\mathbf{V}^{-1}] \cdot \mathbf{U}^{-1} \\  &= [\mathbf{m} \cdot \mathbf{W}\mathbf{V}^{-1} + \mathbf{r}\mathbf{V}^{-1}] \cdot \mathbf{U}^{-1} \\  &= [\mathbf{m} \cdot \mathbf{U}\mathbf{V}\mathbf{V}^{-1} + \mathbf{r}\mathbf{V}^{-1}] \cdot \mathbf{U}^{-1} \\  &= [\mathbf{m} \cdot \mathbf{U} + \mathbf{r}\mathbf{V}^{-1}] \cdot \mathbf{U}^{-1} \\  &\approx \mathbf{m} \cdot \mathbf{U} \cdot \mathbf{U}^{-1} \\  &= \mathbf{m}  \end{align*}\)

  Babai 算法中，如果噪声 \(\mathbf{r}\) 欧几里得范数很小，则步骤 1 的 \(t_i\) 一定更小，四舍五入后就是 0，所以 \([\mathbf{r}\mathbf{V}^{-1}] \approx 0\)。



### 典型加密方案

#### Regev05：加密 1 比特

[On Lattices, Learning with Errors, Random Linear Codes, and Cryptography](https://arxiv.org/pdf/2401.03703)

格的维数为 n，\(\chi\) 是 \( \mathbb{Z}\) 上的噪声高斯分布，其欧几里得范数较小。

- **密钥生成**：私钥为随机向量 \(sk = \mathbf{s} \leftarrow \mathbb{Z}_q^n\)。随机均匀选取矩阵 \(\mathbf{A} \leftarrow \mathbb{Z}_q^{N \times n}\) 和噪声 \(\mathbf{e} \leftarrow \chi^N\)，如下计算

  \(\mathbf{b} := \mathbf{A}\mathbf{s} + \mathbf{e}\)

  则公钥为 \( PK = (\mathbf{A}, \mathbf{b}) \)。

- **加密**：对于消息 \( m \in \{0, 1\} \)，选择随机数 \( \mathbf{r} \in \{0, 1\}^N \)，如下计算

  \(c_1 := \left\lfloor \frac{q}{2} \right\rfloor \cdot m + \mathbf{r}^T \cdot \mathbf{b} \in \mathbb{Z}_q\)

  \(\mathbf{c}_2 := \mathbf{r}^T \mathbf{A} \in \mathbb{Z}_q^n\)

  则密文为 \( (c_1, \mathbf{c}_2) \)。

- **解密**：输入私钥 \( \mathbf{s} \) 和密文 \( (c_1, \mathbf{c}_2) \)，如下计算

  \(  \left\lfloor \frac{2}{q} \left[ (c_1 - \mathbf{c}_2 \cdot \mathbf{s}) \mod q \right] \right\rfloor \mod 2  \)

**展开推导**

\( \begin{align*} \left\lfloor \frac{2}{q} \left[ (c_1 - \mathbf{c}_2 \cdot \mathbf{s}) \mod q \right] \right\rfloor &= \frac{2}{q} \left[ \left\lfloor \frac{q}{2} \right\rfloor \cdot m + \mathbf{r}^T \cdot \mathbf{b} - \mathbf{r}^T \mathbf{A}\mathbf{s} \right] \\ &= \frac{2}{q} \left[ \left\lfloor \frac{q}{2} \right\rfloor \cdot m + \mathbf{r}^T \cdot (\mathbf{A}\mathbf{s} + \mathbf{e}) - \mathbf{r}^T \mathbf{A}\mathbf{s} \right] \\ &= \frac{2}{q} \left[ \left\lfloor \frac{q}{2} \right\rfloor \cdot m + \mathbf{r}^T \cdot \mathbf{e} \right] \\ &= m + e^* \end{align*} \)

当噪声 \( e^* \) 小于 \( \left\lfloor \frac{q}{2} \right\rfloor / 2 \) 时，解密是精确的。注意，噪声 \( \mathbf{r}^T \cdot \mathbf{e} \) 被放大了!!!!

#### BV11：加密 1 比特

[Efficient Fully Homomorphic Encryption from (Standard) LWE](https://eprint.iacr.org/2011/344.pdf)

- **密钥生成**：私钥为随机向量 \( sk = \mathbf{s} \leftarrow \mathbb{Z}_q^n \)。随机均匀选取矩阵 \( \mathbf{A} \leftarrow \mathbb{Z}_q^{N \times n} \) 和噪声 \( \mathbf{e} \leftarrow \chi^N \)，如下计算

  \(\mathbf{b} := \mathbf{A}\mathbf{s} + 2\mathbf{e}\)

  则公钥为 \( PK = (\mathbf{A}, \mathbf{b}) \)。注意：噪声为偶数倍。

- **加密**：对于消息 \( m \in \{0, 1\} \)，选择随机数 \( \mathbf{r} \in \{0, 1\}^N \)，如下计算

  \(c_1 := m + \mathbf{b}^T \cdot \mathbf{r} \in \mathbb{Z}_q\)

  \(\mathbf{c}_2 := \mathbf{A}^T \mathbf{r} \in \mathbb{Z}_q^n\)

- **解密**：输入私钥 \( \mathbf{s} \) 和密文 \( (c_1, \mathbf{c}_2) \)，如下计算

  \((c_1 - \mathbf{c}_2 \cdot \mathbf{s}) \mod q \mod 2\)

**展开推导**

\(\begin{align*} (c_1 - \mathbf{c}_2 \cdot \mathbf{s}) \mod q \mod 2 &= (m + \mathbf{b}^T \cdot \mathbf{r} - \mathbf{A}^T \mathbf{r} \cdot \mathbf{s}) \mod q \mod 2 \\ &= (m + (\mathbf{A}\mathbf{s} + 2\mathbf{e})^T \cdot \mathbf{r} - \mathbf{A}^T \mathbf{r} \cdot \mathbf{s}) \mod q \mod 2 \\ &= m + 2\mathbf{e}^T \mathbf{r} \mod 2 \end{align*}\)

注意，噪声 \(2\mathbf{e}^T \mathbf{r}\) 被放大了!!!!

#### KTX07：加密l比特

[Lattice-based cryptography](https://cims.nyu.edu/~regev/papers/pqc.pdf)

- **密钥生成**：选择随机矩阵 \(\mathbf{S}' \leftarrow \mathbb{Z}_q^{n \times l}\)，则私钥为 \(sk = \mathbf{S} = \begin{bmatrix} \mathbf{I}_l \\ \mathbf{S}' \end{bmatrix} \in \mathbb{Z}_q^{(n+l) \times l}\)。其中，l 维单位阵与矩阵 \(\mathbf{S}'\) 拼接。

  随机均匀选取矩阵\(\mathbf{A}' \leftarrow \mathbb{Z}_q^{N \times n}\) 和噪声矩阵\(\mathbf{E} \leftarrow \chi^{N \times l}\)，如下计算

  \(\mathbf{b} := \mathbf{A}'\mathbf{S}' + \mathbf{E} \in \mathbb{Z}_q^{N \times l}\)

  令\(\mathbf{A} := [\mathbf{b}|- \mathbf{A}'] \in \mathbb{Z}_q^{N \times (n+l)}\)

  则公钥为 \(PK = \mathbf{A}\)。以下等式成立：

  \(\mathbf{A} \cdot \mathbf{S} = [\mathbf{b}|- \mathbf{A}'] \cdot \mathbf{S} = [\mathbf{b}|- \mathbf{A}'] \cdot \begin{bmatrix} \mathbf{I}_l \\ \mathbf{S}' \end{bmatrix} = [\mathbf{A}'\mathbf{S}' + \mathbf{E}] - \mathbf{A}' \cdot \mathbf{S} = \mathbf{E} \ (\text{This is noise.})\)

- **加密**：消息为l维向量 \(\mathbf{m} \in \mathbb{Z}_t^l\)，令 \(\mathbf{m}' = (\mathbf{m}, 0, \dots, 0) \in \{0, 1\}^{n+l}\)。选择随机向量 \(\mathbf{r} \in \{-a, -a+1, \dots, a\}^N\)

  \(\mathbf{c} := \left\lceil \frac{q}{t} \mathbf{m}' \right\rceil + \mathbf{A}^T \cdot \mathbf{r} \in \mathbb{Z}_q^{n+l}\)

  则密文为 \(\mathbf{c}\)。

- **解密**：输入私钥 \(\mathbf{S}\) 和密文 \(\mathbf{c}\)，如下解密

  \(\mathbf{m} := \left\lfloor \frac{t}{q} (\mathbf{S}^T \mathbf{c}) \right\rfloor\)

展开如下

\(\begin{align*} \left\lfloor \frac{t}{q} (\mathbf{S}^T \mathbf{c}) \right\rfloor &= \left\lfloor \frac{t}{q} \left( \mathbf{S}^T \left( \left\lceil \frac{q}{t} \mathbf{m}' \right\rceil + \mathbf{A}^T \cdot \mathbf{r} \right) \right) \right\rfloor \\ &= \left\lfloor \frac{t}{q} \left(  (\begin{bmatrix} \mathbf{I}_l \\ \mathbf{S}' \end{bmatrix})^T  \left\lceil \frac{q}{t} \right\rceil (\mathbf{m}, 0, \dots, 0) + \mathbf{E}^T \cdot \mathbf{r} \right) \right\rfloor \end{align*}\)

注意，噪声 \(\frac{t}{q}\mathbf{E}^T \mathbf{r}\) 被放大了。

#### DGHV10：基于整数的 FHE

[Fully homomorphic encryption over the integers](https://doi.org/10.1007/978-3-642-13190-5_2)

- **密钥生成**：私钥为随机整数 \( p \)。公钥为 \( pq \)，其中 \( q \) 是另一个随机整数。

- **加密**：对于消息 \( m \in \{0,1\} \)，选择噪声 \( e \)，计算
  \[
  c := m + 2e + pq
  \]
  则密文为 \( c \)。

- **解密**：输入私钥 \( p \) 和密文 \( c \)，计算
  \[
  (c\mod p) \mod 2
  \]
  模 \( p \) 去掉了 \( pq \)，模 \( 2 \) 去掉了噪声，留下消息 \( m \)。

- **同态加法**：设密文 \( c = m + 2e + pq \)、\( c' = m' + 2e' + pq' \)，则
  \[
  c + c' = (m + m') + 2(e + e') + p(q + q')
  \]
  解密：\( (c + c' \mod p) \mod 2 = m + m' \)。加法对噪声影响较小。

- **同态乘法**：
  \[
  c \cdot c' = (m + 2e)(m' + 2e') + p(pqq' + mq' + m'q + 2eq' + 2e'q)
  \]
  解密：\( (c \cdot c' \mod p) \mod 2 = (m + 2e)(m' + 2e') \mod p \mod 2 \)。
  关键项 \( (m + 2e)(m' + 2e') \) 乘积后变大，可能超过 \( p \)，则\(\mod p \) 有问题，导致解密出错。

#### LV10：环 LEW 公钥加密

多项式的模运算非常适合图灵计算架构；LV10环LEW公钥加密可以看作是Regev的LEW公钥加密在环上的推广

[On Ideal Lattices and Learning with Errors over Rings](https://link.springer.com/chapter/10.1007/978-3-642-13190-5_1)

- **参数定义**：模 \(q \geq 2\)，多项式次数 \(n \geq 1\) 且为 2 的幂次，多项式 \(f(x) = x^n + 1\)。环 \(R = \mathbb{Z}[x]/(f(x))\)，环 \(R_q = \mathbb{Z}_q[x]/(f(x))\)。\(\chi\) 是 R 上的一个噪声概率分布。

- **密钥生成**

  随机选择 \(\mathbf{s} \in \chi\)，作为**私钥**。随机选择 \(\mathbf{a} \in R_q\)，选择噪声 \(\mathbf{e}_1 \in \chi\)，计算：
  $$
  \mathbf{b} = \mathbf{a}\mathbf{s} + \mathbf{e}_1
  $$
  则**公钥**为 \((\mathbf{b}, \mathbf{a}) \in R_q \times R_q\)。

- **加密**

  消息为 \(\mathbf{m} \in \{0,1\}^n\)，其多项式系数 \(m \in R_q\)。随机选择 \(\mathbf{e}_2, \mathbf{e}_3, \mathbf{e}_4 \in \chi\)，如下计算：
  $$
  c_1 = \left\lfloor \frac{q}{2} \right\rfloor \cdot m + \mathbf{b}\mathbf{e}_2 + \mathbf{e}_3 \in R_q
  $$

  $$
  c_2 = \mathbf{a}\mathbf{e}_2 + \mathbf{e}_4 \in R_q
  $$

  则**密文**为 \(\mathbf{c} = (c_1, c_2)\)​。

- **解密**

  输入私钥 \( \mathbf{s} \) 和密文 \(\mathbf{c}\)，如下解密：

  \(m := \left\lfloor \frac{2}{q} \left( c_1 - c_2\mathbf{s} \mod q \right) \right\rfloor \mod 2\)

**解密过程展开**

\(\begin{align*} \frac{2}{q} \left[ c_1 - c_2\mathbf{s} \right] &= \frac{2}{q} \left[ \left\lfloor \frac{q}{2} \right\rfloor \cdot m + \mathbf{b}\mathbf{e}_2 + \mathbf{e}_3 - (\mathbf{a}\mathbf{e}_2 + \mathbf{e}_4)\mathbf{s} \right] \\ &= \frac{2}{q} \left[ \left\lfloor \frac{q}{2} \right\rfloor \cdot m + (\mathbf{a}\mathbf{s} + \mathbf{e}_1)\mathbf{e}_2 + \mathbf{e}_3 - \mathbf{a}\mathbf{e}_2\mathbf{s} - \mathbf{e}_4\mathbf{s} \right] \\ &= \frac{2}{q} \left[ \left\lfloor \frac{q}{2} \right\rfloor \cdot m + \mathbf{e}_1\mathbf{e}_2 + \mathbf{e}_3 - \mathbf{e}_4\mathbf{s} \right] \\ &= m + \frac{2}{q} \left( \mathbf{e}_1\mathbf{e}_2 + \mathbf{e}_3 - \mathbf{e}_4\mathbf{s} \right) \\ &= m + e^* \end{align*}\)

#### LV10 变形

方案特点： 2 倍噪声，则加密不需要放大消息，解密不需要缩小消息。

模 $$q\ge 2$$，多项式次数 $$n\ge 1$$ 且为 2 的幂次方，多项式为 $$f(x)=x^n+1$$。环 $$R=\mathbb{Z}[x]/f(x)$$，环 $$R_q=\mathbb{Z}_q[x]/f(x)$$。$$\chi$$ 是 $$R$$ 上的噪声概率分布。

- **密钥生成：** 随机选择 $$s\in\chi$$，作为私钥。随机选择 $$a \in R_q$$，选择 $$e_1\in\chi$$，计算

$$
b = a s + 2 e_1
$$

​    则公钥为 $$(b,a)$$。

- **加密：** 消息为 $$m\in\{0,1\}^n$$，其多项式系数 $$m\in R_2$$。随机选择 $$e_2,e_3,e_4\xleftarrow{\$}\chi$$，如下计算：

$$
c_1 = m + b e_2 + 2e_3 \in R_q,
$$

$$
 c_2 = a e_2 + 2 e_4 \in R_q.
$$

则密文为 $$c=(c_1,c_2)$$。

- **解密：** 输入私钥 $$s$$ 和密文 $$ c $$，如下解密：

$$
 m := c_1 - c_2 s \bmod q \bmod 2
$$

展开如下：
$$
\begin{aligned}
c_1 - c_2 s \bmod q \bmod 2 &= m + b e_2 + 2e_3 - (a e_2 + 2 e_4) s \bmod q \bmod 2 \\
&= m + (a s + 2 e_1) e_2 + 2e_3 - (a e_2 + 2 e_4) s \bmod q \bmod 2 \\
&= m + 2 e_1 e_2 + 2 e_3 - 2 e_4 s \bmod q \bmod 2 \\
&= m + 2 e^* \bmod 2 \\
&= m
\end{aligned}
$$
其中 $$e^*=e_1 e_2 + e_3 - e_4 s$$。





### 关键技术

#### Bootstrapping 自举

自举技术是 Gentry 实现全同态加密的奠基石。Gentry 在实现全同态加密时，注意到如果同时执行自己的解密算法，即输入的密文是对原密文中每一位加密的结果，输入的密钥是对原密文密钥每一位加密的结果，那么经过同态执行解密算法就会得到一个新的密文，这个新的密文噪声是固定的。因此，可以通过同态解密技术约束（管理）密文的噪声。

1. **密钥生成**：私钥和公钥对分别为 \((sk_1, pk_1)\)、\((sk_2, pk_2)\)。
2. **加密**：使用 \(pk_1\) 对明文 m 加密 \(\langle m \rangle = \text{Enc}(pk_1, m)\)。注意，私钥 \(sk_1\) 能脱掉\(\langle \rangle\)
   - Dec 算法：输入 \(sk_1\) 和 \(\langle m \rangle\)，进行 \(k_1\) 次加法和 \(k_2\) 次乘法的组合，则脱掉\(\langle \rangle\)。
3. **加密**：使用 \(pk_2\) 对密文 \(\langle m \rangle\) 加密 $[ \langle m \rangle ] = \text{Enc}(pk_2, \langle m \rangle)$。注意，私钥 \(sk_2\) 能脱掉\([ ]\)，需要 \(k_1\) 次加法和 \(k_2\) 次乘法的组合。
4. **加密**：使用 \(pk_2\) 对密文 \(sk_1\) 加密 \([ sk_1 ] = \text{Enc}(pk_2, sk_1)\)。
5. **同态运算**：密文进行同态加法和同态乘法，等价于明文做对应的加法和乘法。因此，输入 \([ sk_1 ]\) 和 \([ \langle m \rangle ]\)，进行 \(k_1\) 次同态加法和 \(k_2\) 次同态乘法的组合，则能够脱掉\(\langle \rangle\)，获得 \([ m ]\)。

等价于同态解密：\([ m ] = \text{Dec}([ sk_1 ], [ \langle m \rangle ])\) 用 \([ sk_1 ]\) 脱掉\(\langle \rangle\)，还剩\([ ]\)。

**核心思想**：步骤 3 到步骤 5（明文 m 和私钥 \(sk_1\) 不泄露）

- 假设密文 \(\langle m_0 \rangle\)，经过 n 次同态运算变为密文 \(\langle m_n \rangle'\)。此时噪声积累很严重（多了\('\)），后续仅能进行 \(k_1\) 次同态加法和 \(k_2\) 次同态乘法运算了。
- 使用步骤 3、4、5，执行 \(k_1\) 次同态加法和 \(k_2\) 次同态乘法，将密文 \(\langle m_n \rangle'\) 变为密文 \([ m_n ]\)，则能够进行 n 次同态运算，变为 \([ m_{2n} ]'\)。此时噪声积累很严重（多了\('\)），仅剩余 \(k_1\) 次同态加法和 \(k_2\) 次同态乘法运算了。
- 再使用步骤 3、4、5，则又可以同态运算 n 次，而不泄露明文 m 和私钥 \(sk_1\)。

**Bootstrapping 自举**：每同态运算 n 次后，则自举，再同态运算 n 次，再自举，以此类推。

由于每层电路（\(k_1\) 次加法和 \(k_2\) 次乘法运算的组合）都需要密钥对 \((pk_1, sk_1)\)，所以层次型全同态加密算法的公钥 \((pk_1, pk_2, \cdots, pk_{L+1})\) 和 \((sk_1, sk_2, \cdots, sk_L)\) 构成。如果是循环安全的，每层电路就可以使用相同的密钥对，减少密钥数量。尽管同态解密是实现全同态加密的基石，但同态解密的效率很低，其复杂度为 \(O(\lambda^3)\)。

Bootstrapping 是一种通用的管理噪声的技术，可以应用于所有 FHE 算法，只要解密电路的深度小于算法本身的同态计算电路的深度。

#### 位展开

当噪声主要依赖于某一个向量 \(\mathbf{x} \in \mathbb{Z}_q^n\) 时，为降低噪声的影响，可将该向量**位展开**，即将向量中的每个**元素**展开成二进制形式，从而向量 \(\mathbf{x}\) 范数 \(L_1(\mathbf{x})\) 的最大值从 nq 变成 \(n\log q\)，降低噪声。

1. \(\text{BitDecomp}(\mathbf{x})\): \(\mathbf{x} \in \mathbb{Z}^n\)，令 \(\mathbf{w}_i \in \{0,1\}^n\)，满足：\(\mathbf{x} = \sum_{i=0}^{\lceil \log q \rceil - 1} 2^i \cdot \mathbf{w}_i \ (\text{mod}\ q)\)，输出：

   \((\mathbf{w}_0, \mathbf{w}_1, \cdots, \mathbf{w}_{\lceil \log q \rceil - 1}) \in \{0,1\}^{n \lceil \log q \rceil}\)

   $w_i$表示各x为二进制形式后i位的二进制数。

2. \(\text{BitDecomp}^{-1}(\mathbf{y})\) 是 \(\text{BitDecomp}(\mathbf{x})\) 的逆运算。令：

   \(\mathbf{y} = (\mathbf{w}_0, \mathbf{w}_1, \cdots, \mathbf{w}_{\lceil \log q \rceil - 1})\)

   则 \(\text{BitDecomp}^{-1}(\mathbf{y})\) 输出：

   \(\sum_{i=0}^{\lceil \log q \rceil - 1} 2^i \cdot \mathbf{w}_i \ (\text{mod}\ q)\)

   即使向量 \(\mathbf{w}\) 中的元素不是 0 和 1，该定义依然成立。

3. \(\text{Flatten}(\mathbf{y})\): 令 \(\text{Flatten}(\mathbf{y}) = \text{BitDecomp}(\text{BitDecomp}^{-1}(\mathbf{y}))\)，则 \(\text{Flatten}(\mathbf{y})\) 是一个元素为 0 和 1 构成的向量。

   因此，\(\text{Flatten}\) 能够将一个元素不是 0 和 1 的向量转化成一个元素为 0 和 1 的向量，而维数不变。Gentry 等在 2013 年提出使用 \(\text{Flatten}\) 技术作为密文噪声管理。

向量**位展开**后，为了使得向量的内积保持不变，需要另外一个向量变成如下形式：

1. \(\text{Powersof2}(\mathbf{y})\): 输入 \(\mathbf{y} \in \mathbb{Z}^n\)，输出

   \((\mathbf{y}, 2\mathbf{y}, \cdots, 2^{\lceil \log q \rceil - 1}\mathbf{y}) \ \text{mod}\ q \in \mathbb{Z}^{n \lceil \log q \rceil}\)

对于所有 \(\mathbf{x} \in \mathbb{Z}_q^n\) 和 \(\mathbf{y} \in \mathbb{Z}_q^n\)，有如下性质：

\(\langle \mathbf{x}, \mathbf{y} \rangle = \langle \text{BitDecomp}(\mathbf{x}), \text{Powersof2}(\mathbf{y}) \rangle = \langle \text{Powersof2}(\mathbf{x}), \text{BitDecomp}(\mathbf{y}) \rangle\)

同理，对于任何一个 \(n \cdot \lceil \log q \rceil\) 维向量 \(\mathbf{a}\)，有：

\(\langle \mathbf{a}, \text{Powersof2}(\mathbf{y}) \rangle = \langle \text{BitDecomp}^{-1}(\mathbf{a}), \mathbf{y} \rangle = \langle \text{Flatten}(\mathbf{a}), \text{Powersof2}(\mathbf{y}) \rangle\)

很简单，相当于powersof2(y)给了bitdecomp(x)每一位二进制位的权。



**例子bitdecomp(x)**

令 \(\mathbf{x} = [3, 4] \in \mathbb{Z}^2\)，\(q=5\) 则 \(k = \lceil \log_2 5 \rceil = 3\)。

- 对 \(\mathbf{x}\) 的每个元素拆分为 3 个二进制位（模 5）：
  - 元素 1：\(3 = 1 \cdot 2^0 + 1 \cdot 2^1 + 0 \cdot 2^2\)
  - 元素 2：\(4 = 0 \cdot 2^0 + 0 \cdot 2^1 + 1 \cdot 2^2\)
- 构造 \(\mathbf{w}_i\)：
  - \(\mathbf{w}_0\)（第 0 位，\(2^0\)）：取两个元素的第 0 位 → \([1, 0]\)
  - \(\mathbf{w}_1\)（第 1 位，\(2^1\)）：取两个元素的第 1 位 → \([1, 0]\)
  - \(\mathbf{w}_2\)（第 2 位，\(2^2\)）：取两个元素的第 2 位 → \([0, 1]\)
- 输出：\((\mathbf{w}_0, \mathbf{w}_1, \mathbf{w}_2) = ([1,0], [1,0], [0,1])\)，展开为向量是 \([1,0,1,0,0,1]\)，维度 \(2 \times 3 = 6\)，符合 \(\{0,1\}^{2 \times 3}\)。

**Powersof2(y)**

\(\text{Powersof2}(y) = (y, 2y, 2^{k-1}y) \mod q\)，其中 \(y = (3, 1)\)：

- 第一项：\(y = (3, 1) \mod 5\)，结果为 \((3, 1)\)。
- 第二项：\(2y = (2 \times 3, 2 \times 1) = (6, 2) \mod 5\)，结果为 \((1, 2)\)。
- 第三项：\(2^{2}y = (4 \times 3, 4 \times 1) = (12, 4) \mod 5\)，结果为 \((2, 4)\)。

因此，\(\text{Powersof2}(y)\) 对应的**矩阵**为：

\(\begin{pmatrix} 3 & 1 & 2 \\ 1 & 2 & 4 \end{pmatrix}\)

展开为向量是 \([3, 1, 1, 2, 2, 4]\)，维度为 \(2 \times 3 = 6\)。

**内积**

$⟨x,y⟩=3×3+4×1=9+4=13mod5=3$

$\langle \text{BitDecomp}(\mathbf{x}), \text{Powersof2}(\mathbf{y}) \rangle=1×3+1×1+0×2+0×1+0×2+1×4=3+1+0+0+0+4=8mod5=3$



### 四代全同态加密

四代 FHE 的特点与区别：

- 第一代：引入 **Bootstrapping** 技术，在理论上首次支持无限次同态运算。代表作为 2009 年 Gentry 和 2010 年 DGHV，均为 “基于整数” 分支。
- 第二代：对 arithmetic 电路，FHE 进入实用阶段。代表作为 2011 年 BGV、2012 年 LTV、2012 年 BFV（属 leveled schemes 分支）、2013 年 BLLN（属 NTRU 分支）。**再线性化 / 密钥交换**、**模交换技术**，避免使用昂贵的 Bootstrapping 技术，提升效率。
- 第三代：对 Boolean 电路，降低同态运算中的误差积累。代表作为 2013 年 GSW、2014 年 FHEW（属 fast bootstrapping 分支）。GSW 使用简单的比特转换技术实现 Leveled-FHE 方案。
- 第四代：支持浮点数计算。代表作为 2016 年 CKKS（属 leveled schemes 分支）、2016 年 TFHE（属 fast bootstrapping 分支）。对于浮点数、复数域上的计算，CKKS16 方案基于 RLWE 问题，所以本质上是在整数上计算。CKKS16 将浮点数、复数编码为整数，再进行后续计算。如，m 是一个浮点数，编码为整数，则乘以扩张因子\(\delta\)，再进行取整。对编码后数计算乘法，扩张因子变为\(\delta^2\)，所以需要消去一个\(\delta\)，即在 CKKS 中的 rescale 操作。

#### 第 1 代：基于理想格和 AGDC

##### Gentry09

[Fully homomorphic encryption using ideal lattices](https://www.doubao.com/chat/29867412125753346) [Fully homomorphic encryption for mathematicians](https://www.doubao.com/chat/29867412125753346)

**理想**：\( \mathbb{I} \) 是环 \(\mathbb{R}\) 的一个子集，包含 0（即加法的逆元素），满足以下条件：

1. \(\mathbb{I}\) 中两个元素的加法结果仍然在 \(\mathbb{I}\) 中；
2. 吸收性：对任意 r∈R、a∈I，都有 r・a∈I 且 a・r∈I（左吸收 + 右吸收）

栗子：比如整数环Z，和理想2Z

**主理想**是由一个元素（生成元）生成的理想，即由 a 生成的主理想是 a 的倍数组成的集合。

栗子：比如选2，2与Z中所有元素相乘得到理想2Z，或者选3，得理想3Z，这个2/3叫生成元。

由单个多项式 \(f(x) \in R\) 生成的**主理想** \((f(x)) = \{ f(x) \cdot g(x) \mid g(x) \in R \}\)，它满足：对任意 \(r(x) \in R\)、\(a(x) \in (f(x))\)，有 \(r(x) \cdot a(x) \in (f(x))\)（吸收性）

**Gentry09 方案**：使用由理想 \( \mathbb{I} \) 定义的整数格子 \(L(\mathbb{I}) \subseteq \mathbb{Z}^m\)。

栗子：

1. 取多项式环 \(R = \mathbb{Z}[x]/(x^2 + 1)\)（即复数的整数部分，\(x^2 \equiv -1\)）；

2. 取主理想 \(\mathfrak{I} = (2 + x)\)（由多项式 \(2 + x\) 生成）；

3. 理想中的元素是 \((2 + x) \cdot (a + bx) = (2a - b) + (a + 2b)x\)（模 \(x^2 + 1\)），对应的向量为 \((2a - b, a + 2b)\)（\(a, b \in \mathbb{Z}\)）；

4. 这些向量在二维平面上构成的网格就是**理想格**，其结构由多项式 \(2 + x\) 的系数决定。

   

- **密钥生成**：公钥矩阵 \(B_{pk}\) 和私钥矩阵 \(B_{sk}\) 分别是理想格 \(L(\mathbb{I})\) 的劣质基与优质基。

- **加密**：消息是 1 个比特，\( m \in \{0,1\} \)，如下计算

  \(\mathbf{a} = m + 2\mathbf{e} \in \mathbb{R}^d\)

  其中，\(\mathbf{e}\)是噪声，即一个随机向量，其系数属于\(\{0, \pm 1\}\)，且\(\pm 1\)取值的概率相等。

  密文\(\mathbf{c}\)是点\(\mathbf{a}\)在平行多面体\(P(B_{sk})\)中的平移，其中，\(B_{pk}\) 是公钥。即\(\mathbf{c} = \mathbf{a} - \lfloor \mathbf{a} B_{pk}^{-1} \rfloor B_{pk}\)其中，\(\lfloor \cdot \rfloor\)表示四舍五入到最近的整数。

  分析：使用\(\lfloor \mathbf{a} B_{pk}^{-1} \rfloor\)对劣质基\(B_{pk}\)中的向量线性组合，获得一个随机格点；然后加上一个随机距离\(\mathbf{a}\)，获得一个不在格L中的随机点\(\mathbf{c}\)。

- **解密**：计算\(\mathbf{a}' = \mathbf{c} - \lfloor \mathbf{c} B_{sk}^{-1} \rfloor B_{sk}\)

  这表示将\(\mathbf{c}\)平移到平行多面体\(P(B_{sk})\)，其中，\(B_{sk}\)是私钥。然后计算\(\mathbf{a}' \mod 2\)获得m。

  分析：使用优质基\(B_{sk}\)，是对不在格L中的随机点\( c \)去掉噪声，则获得一个与随机点\(\mathbf{c}\)最近的格点\(\lfloor \mathbf{c} B_{sk}^{-1} \rfloor B_{sk}\)，即解决 CVP 困难问题，然后作差。

- **同态加法**：整数环中的加法 \(\mathbf{c} + \mathbf{c}' = \mathbf{a} + \mathbf{a}' - (\lfloor \mathbf{a} B_{pk}^{-1} \rfloor + \lfloor \mathbf{a}' B_{pk}^{-1} \rfloor) B_{pk}\)

- **解密**：基于优质基，找到最近格点，然后获得距离 \(\mathbf{a} + \mathbf{a}'\)。

- **同态乘法**：整数环中的乘法

  \(\mathbf{c} \times \mathbf{c}' = \left( \mathbf{a} - \lfloor \mathbf{a} B_{pk}^{-1} \rfloor B_{pk} \right) \times \left( \mathbf{a}' - \lfloor \mathbf{a}' B_{pk}^{-1} \rfloor B_{pk} \right) = \mathbf{a}\mathbf{a}' - \mathbf{a} \lfloor \mathbf{a}' B_{pk}^{-1} \rfloor B_{pk} - \mathbf{a}' \lfloor \mathbf{a} B_{pk}^{-1} \rfloor B_{pk} + \lfloor \mathbf{a} B_{pk}^{-1} \rfloor B_{pk} \lfloor \mathbf{a}' B_{pk}^{-1} \rfloor B_{pk}\)

  分析：第 1 项是距离，后 3 项是随机格点。注意最后一个格点*格点=格点是在**理想格**上实现的。

上述方案由于解密算法的复杂性（即无法同态评估）而无法进行引导自举（Bootstrapping 同态解密）。

为了解决该问题，Gentry 提出了一个方法，通过对原始的同态加密方案 E 进行变换，得到一个新的方案 \(E'\)，该方案具有相同的同态能力，但具有一个简化的解密函数，从而允许 Bootstrapping。

为了降低解密算法的复杂性，Gentry 证明只需在评估密钥中添加一些关于私钥的 “额外信息”。这些额外信息由一组向量 \(S = \{s_k | k = 1, \dots, S\}\) 组成，从中导出一个子集 T，私钥 sk 是 T 元素的和，评估密钥中包含的公钥信息是集合 S。该新方案 \(E'\) 的安全性基于：集合 T 是稀疏的且是私有的，因此适用稀疏子集和困难问题（SSSP）。

该方案的安全基于 4 个困难问题：

1. 稀疏子集和困难问题（SSSP）：已知 n 个整数 \(S = \{a_1, \dots, a_n\} \subseteq \mathbb{Z}\)，判断是否存在集合 S 的子集 L，满足 \(\sum_{i \in L} a_i = 0\)。
2. 有界距离解码困难问题（CVP 困难问题的变形）：已知一个目标向量 \(\mathbf{t}\)，使得 \(\text{dist}(\mathbf{t}, L) < \alpha \lambda_1(L)\)，其中，\(\lambda_1(L)\) 是格 L 的第一个最短基向量的长度。求与 \(\mathbf{t}\) 最接近的一个格向量 \(\mathbf{v} \in L\)。
3. 理想最短向量困难问题（SVP 困难问题的变形）：在格 L 中找到一个最短的非零向量。其中，\(\lambda_1(L) \leq \lambda_2(L)\) 且 \(\gamma \geq 1\)。换句话说，最短向量的长度保证至少是 \(\lambda_2(L)\) 的 \(\gamma\) 倍小。
4. 循环安全。

**安全问题**：CDPR16 发现了使用主理想方案的一个漏洞：在给定一个量子多项式时间，或经典的 \(2^{n^{2/3 - \epsilon}}\) 时间算法的情况下，可以进行密钥恢复攻击，攻击目标是基于主理想格的加密构造。[Recovering Short Generators of Principal Ideals in Cyclotomic Rings](https://www.doubao.com/chat/29867412125753346)

##### DGHV10

[Fully homomorphic encryption over the integers](https://doi.org/10.1007/978-3-642-13190-5_2)

- **密钥生成**：私钥为\( p \)，即一个奇数随机整数，以及公钥\( (x_0, \dots, x_n) \)。\( x_0 \)是奇数，且\( x_0 > x_i, \forall i \)
  \[
  x_i = pq_i + r_i
  \]
  其中\( q_i, r_i \)是随机整数。

- **加密**：消息\( m \in \mathbb{F}_2 \)，如下计算
  \[
  c = \left( m + 2r + 2\sum_{i \in S} x_i \right) \mod x_0
  \]
  其中，\( r \)是一个随机整数，\( S \)是\( \{1, \dots, n\} \)的一个随机子集。

- **解密**：计算\( (c \mod p) \mod 2 \)

该方案的安全性基于稀疏子集和问题（SSSP）以及近似最大公约数（AGCD）困难问题。

- **SSSP困难问题**：已知\( n \)个整数\( S = \{a_1, \dots, a_n\} \subseteq \mathbb{Z} \)，判断是否存在集合\( S \)的子集\( \mathbb{I} \)，满足\( \sum_{i \in \mathbb{I}} a_i = 0 \)。

- **AGCD困难问题**：已知随机选择的整数集\( \{x_0, \dots, x_n\} \in \mathbb{Z} \)，求解“共同近似除数”\( p \)。

#### 第 2 代：基于 LWE 和 RLWE

##### 基础数学知识

- 向量张量积是向量外积 \(\mathbf{a} \otimes \mathbf{b} = (a_1, a_2) \otimes (b_1, b_2) = (a_1b_1, a_1b_2, a_2b_1, a_2b_2)\)；
- 矩阵 Kronecker 积是矩阵外积 \(\mathbf{A} \otimes \mathbf{B}\)。

\(\begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix} \otimes \begin{bmatrix} 0 & 5 \\ 6 & 7 \end{bmatrix} = \begin{bmatrix} 1 \begin{bmatrix} 0 & 5 \\ 6 & 7 \end{bmatrix} & 2 \begin{bmatrix} 0 & 5 \\ 6 & 7 \end{bmatrix} \\ 3 \begin{bmatrix} 0 & 5 \\ 6 & 7 \end{bmatrix} & 4 \begin{bmatrix} 0 & 5 \\ 6 & 7 \end{bmatrix} \end{bmatrix} = \begin{bmatrix} 0 & 5 & 0 & 10 \\ 6 & 7 & 12 & 14 \\ 0 & 15 & 0 & 20 \\ 18 & 21 & 24 & 28 \end{bmatrix}\)

Kronecker 积有以下 9 个性质，最后 2 个是矩阵性质。

1. \(\mathbf{A} \otimes (\mathbf{B} + \mathbf{C}) = \mathbf{A} \otimes \mathbf{B} + \mathbf{A} \otimes \mathbf{C}\)，要求 \(\mathbf{B}\) 和 \(\mathbf{C}\) 相同尺寸
2. \((\mathbf{A} + \mathbf{B}) \otimes \mathbf{C} = \mathbf{A} \otimes \mathbf{C} + \mathbf{B} \otimes \mathbf{C}\)，要求 \(\mathbf{A}\) 和 \(\mathbf{B}\) 相同尺寸
3. \(k\mathbf{A} \otimes \mathbf{B} = \mathbf{A} \otimes k\mathbf{B} = k(\mathbf{A} \otimes \mathbf{B})\)
4. \((\mathbf{A} \otimes \mathbf{B}) \otimes \mathbf{C} = \mathbf{A} \otimes (\mathbf{B} \otimes \mathbf{C})\)
5. \((\mathbf{A} \otimes \mathbf{B})(\mathbf{C} \otimes \mathbf{D}) = (\mathbf{AC}) \otimes (\mathbf{BD})\)
6. \((\mathbf{A} \otimes \mathbf{B})^T = \mathbf{A}^T \otimes \mathbf{B}^T\)
7. \((\mathbf{A} \otimes \mathbf{B})^{-1} = \mathbf{A}^{-1} \otimes \mathbf{B}^{-1}\)
8. \(\mathbf{A} \otimes \mathbf{B} \neq \mathbf{B} \otimes \mathbf{A}\)
9. \(\mathbf{B} \otimes \mathbf{A} = \mathbf{P}(\mathbf{A} \otimes \mathbf{B})\mathbf{Q}\)，\(\mathbf{P}\) 和 \(\mathbf{Q}\) 是置换矩阵
10. \((\mathbf{AB})^T = \mathbf{B}^T \mathbf{A}^T\)，矩阵性质
11. \((\mathbf{AB})^{-1} = \mathbf{B}^{-1} \mathbf{A}^{-1}\)，矩阵性质

##### 对称加密

[Efficient Fully Homomorphic Encryption from (Standard) LWE](https://eprint.iacr.org/2011/344.pdf)，在 BGV14 方案中的基于 LWE 的公钥加密类似。

- **对称密钥**：选择随机数 \(\mathbf{s} \in \mathbb{Z}_q^n\)，则私钥为 \(\overline{\mathbf{s}} = (-\mathbf{s}, 1) \in \mathbb{Z}_q^{n+1}\)。
- **加密**：消息为 \( m \in \mathbb{F}_2 \)，令 \(\mathbf{m} = (m, 0, ..., 0) \in \mathbb{F}_2^k\)，选择随机矩阵 \(\mathbf{A} \in \mathbb{Z}_q^{k \times n}\) 和噪声 \(\mathbf{e} \in \mathbb{Z}_q^k\)，e 从误差分布 \(\chi\) 中随机选择的，计算

\(\mathbf{c} = (\mathbf{A}, \mathbf{b}) = (\mathbf{A}, \langle \mathbf{A}, \mathbf{s} \rangle + 2\mathbf{e} + \mathbf{m}) \in \mathbb{Z}_q^{k \times n} \times \mathbb{Z}_q^k\)

则密文为 \(\mathbf{c} = (\mathbf{A}, \mathbf{b})\)。

- **解密**：输入私钥 \(\overline{\mathbf{s}} = (-\mathbf{s}, 1)\) 和密文 \(\mathbf{c} = (\mathbf{A}, \mathbf{b})\)，如下计算

\(\langle \mathbf{c}, \overline{\mathbf{s}} \rangle \mod q \mod 2 = (\mathbf{b} - \langle \mathbf{A}, \mathbf{s} \rangle \mod q) \mod 2 = (\langle \mathbf{A}, \mathbf{s} \rangle + 2\mathbf{e} + \mathbf{m} - \langle \mathbf{A}, \mathbf{s} \rangle \mod q) \mod 2\)

- **同态加法**：

\(\begin{align*} \mathbf{c} + \mathbf{c}' &= (\mathbf{A}, \mathbf{b}) + (\mathbf{A}', \mathbf{b}') \\ &= (\mathbf{A} + \mathbf{A}', \langle \mathbf{A}, \mathbf{s} \rangle + 2\mathbf{e} + \mathbf{m} + \langle \mathbf{A}', \mathbf{s} \rangle + 2\mathbf{e}' + \mathbf{m}') \\ &= (\mathbf{A} + \mathbf{A}', \langle \mathbf{A} + \mathbf{A}', \mathbf{s} \rangle + 2(\mathbf{e} + \mathbf{e}') + \mathbf{m} + \mathbf{m}') \\ &= (\mathbf{A}'', \langle \mathbf{A}'', \mathbf{s} \rangle + 2\mathbf{e}'' + \mathbf{m}'') \\ &= (\mathbf{A}'', \mathbf{b}'') \\ &= \mathbf{c}'' \end{align*}\)

其中，\(\mathbf{m}'' = \mathbf{m} + \mathbf{m}'\)。注意，\(\mathbf{e}'' = \mathbf{e} + \mathbf{e}'\) 噪声有积累。同态加法情况下影响较小。

- **解密（同态加法后）**：输入私钥 \(\overline{\mathbf{s}} = (-\mathbf{s}, 1)\) 和密文 \(\mathbf{c}'' = (\mathbf{A}'', \mathbf{b}'')\)，如下计算

\(\mathbf{m} + \mathbf{m}' := \langle \mathbf{c}'', \overline{\mathbf{s}} \rangle = (\mathbf{b}'' - \langle \mathbf{A}'', \mathbf{s} \rangle \mod q) \mod 2\)

- **同态乘法**：\(\mathbf{c} \otimes \mathbf{c}'\)
  - **解密**：私钥 \(\overline{\mathbf{s}}\) 扩展为新私钥 \(\overline{\mathbf{s}} \otimes \overline{\mathbf{s}}\)。注意：私钥长度增加了。如下计算

\(\begin{align*} \langle \mathbf{c} \otimes \mathbf{c}', \overline{\mathbf{s}} \otimes \overline{\mathbf{s}} \rangle &= (\mathbf{c} \otimes \mathbf{c}')^T (\overline{\mathbf{s}} \otimes \overline{\mathbf{s}}) \\ &= (\mathbf{c}^T \otimes \mathbf{c}'^T)(\overline{\mathbf{s}} \otimes \overline{\mathbf{s}}) = (\mathbf{c}^T \overline{\mathbf{s}}) \otimes (\mathbf{c}'^T \overline{\mathbf{s}}) \\ &= \langle \mathbf{c}, \overline{\mathbf{s}} \rangle \otimes \langle \mathbf{c}', \overline{\mathbf{s}} \rangle \\ &= \mathbf{m} \otimes \mathbf{m}' = mm' \end{align*}\)

其中，等号 1：内积；等号 2：性质 6；等号 3：性质 5；等号 4：内积；等号 6：常规解密。

- **论文引入 2 种新技术**：再线性化和维度模缩小。
  - **再线性化**是必要的，以将乘法密文大小从接近 \(n^2/2\) 降到常规大小，即 \(n + 1\)。为了实现这一减少，通过 “加密” 对称密钥的所有项来转换 \(c_1 \cdot c_2\) 的二阶方程为线性方程。随后，Brakerski、Gentry 和 Vaikuntanathan [(Leveled) Fully Homomorphic Encryption without Bootstrapping](https://dl.acm.org/doi/10.1145/2633600) 将这一技术称为**密钥交换（Key Switching）**。
  - **维度模缩小**，即模交换技术，将同态加密方案（SHE）转换为完全同态加密方案，通过将密文 c 对模 q 的取模转换为密文 \(c'\) 对模 p 的取模。其中，p 比 q 小得多。具体而言，先将 \(\mathbb{Z}_q\) 中的每个元素乘以 \(p/q\)，然后取最近的整数。此操作的一个有趣副作用是密文中的误差减少。由于采用了模切换，噪声增长较低，这使得可以同态评估解密电路，而无需 Gentry 提出的压缩方法，使得 SSSP 假设不再是必需的。

##### BGV14

[*(Leveled) fully homomorphic encryption without bootstrapping*](https://dl.acm.org/doi/10.1145/2633600)

设d为 2 的幂，q为奇正整数模，\(\chi\)为R上的误差分布。其中，\(R = \mathbb{Z}[x]/\langle x^d + 1 \rangle\)。设B为\(\chi\)输出元素长度的界限（以极高的概率），并且B被设置为尽可能小以保持安全性。对于任意自然数p，\(R_p = \mathbb{Z}_p[x]/\langle x^d + 1 \rangle\)。

**密钥生成**

输入安全参数\(\lambda\)，随机选择一个小的秘密元素\(s \in \chi\)，并设置私钥\(sk = \mathbf{s} = (1, s) \in R_q^2\)。随机均匀生成一个\(a' \in R_q\)，然后计算\(b = a's + 2e\)（其中e是从\(\chi\)中随机选择的误差）。输出sk和公钥\(pk = \mathbf{a} = (b, -a')\)。以下等式成立：

\(\langle \mathbf{a}, \mathbf{s} \rangle = \langle (b, -a'), (1, s) \rangle = \langle (a's + 2e, -a'), (1, s) \rangle = 2e\)

**加密**

输入公钥\(pk \in R_q^2\)和消息\(m \in R_2\)，将m转换为向量\(\mathbf{m} = (m, 0) \in R_q^2\)并选择噪声\(r, e_0, e_1 \in \chi\)。输出密文为：

\(\mathbf{c} = \mathbf{m} + 2(e_0, e_1) + \mathbf{a}\ r \\ = (m + 2e_0 + b\ r, 2e_1 - a'\ r) \in R_q^2 \\ = (c_0, c_1)\)

**解密**

输入私钥\(\mathbf{s} \in R_q^2\)和密文\(\mathbf{c} \in R_q^2\)，计算内积：

\(\langle \mathbf{c}, \mathbf{s} \rangle = \langle (c_0, c_1), (1, s) \rangle \\ = c_0 + c_1\ s \\ = m + 2e_0 + b\ r + (2e_1 - a'\ r)s \\ = m + 2e_0 + (a's + 2e)r + (2e_1 - a'\ r)s \\ = m + 2e_0 + 2e_1\ s + 2e\ r\)

再对结果进行\(\mod q \mod 2\)运算，即可获得明文m。

*注意*：解密能正常工作是因为\(e, e_0, e_1\)和s足够小（因为它们是\(\chi\)的元素）,一般是不能超过$q/2$向下取整。

**同态加法**

对两个密文\(\mathbf{c} = (c_0, c_1)\)和\(\mathbf{c}' = (c_0', c_1')\)执行对应相加：

\(\mathbf{c} + \mathbf{c}' = (c_0, c_1) + (c_0', c_1') \\ = (m + 2e_0 + b\ r, 2e_1 - a'\ r) + (m' + 2e_0' + b\ r', 2e_1' - a'\ r') \\ = (m + m' + 2(e_0 + e_0') + b(r + r'), 2(e_1 + e_1') - a'(r + r')) \\ = (m'', 2e_0'' + b\ r'', 2e_1'' - a'\ r'') \\ = (c_0'', c_1'') \\ = \mathbf{c}''\)

**加法后解密验证**

对加法结果\(\mathbf{c}''\)解密：

\(\langle \mathbf{c}'', \mathbf{s} \rangle = \langle (c_0'', c_1'') , (1, s) \rangle \\ = c_0'' + c_1''\ s \\ = m'' + 2e_0'' + b\ r'' + (2e_1'' - a'\ r'')s \\ = m'' + 2e_0'' + (a's + 2e)r'' + (2e_1'' - a' r'')s \\ = m'' + 2e_0'' + 2e_1''\ s + 2e\ r''\)

再对结果进行\(\mod q \mod 2\)运算，可获得\(m'' = m + m'\)。

*结论*：只要结果中的误差不与模q重叠，解密就能正常工作。

**同态乘法**

密文乘法运算\(\mathbf{c} \otimes \mathbf{c}'\)的核心是私钥扩展为\(\mathbf{s} \otimes \mathbf{s}\)（私钥长度会增加）。解密验证如下：

\(\langle \mathbf{c} \otimes \mathbf{c}', \mathbf{s} \otimes \mathbf{s} \rangle \\ = \langle \mathbf{c}^T \otimes \mathbf{c}'^T \rangle (\mathbf{s} \otimes \mathbf{s}) \\ = \langle \mathbf{c}^T \otimes \mathbf{s} \rangle (\mathbf{c}'^T \otimes \mathbf{s}) \\ = \langle \mathbf{c}, \mathbf{s} \rangle \otimes \langle \mathbf{c}', \mathbf{s} \rangle \\ = \mathbf{m} \otimes \mathbf{m}' \\ = m \cdot m'\)

##### 核心技术：密钥交换 / 再线性化

**解密分析**

\(\begin{align*} \langle \mathbf{c} \otimes \mathbf{c}', \mathbf{s} \otimes \mathbf{s} \rangle &= \langle \mathbf{c}, \mathbf{s} \rangle \cdot \langle \mathbf{c}', \mathbf{s} \rangle \\ &= (c_0 + c_1 s)(c_0' + c_1' s) \\ &= c_0 c_0' + (c_0 c_1' + c_1 c_0') s + c_1 c_1' s^2 \\ &= d_0 + d_1 s + d_2 s^2 \\ &= \langle (d_0, d_1, d_2), (1, s, s^2) \rangle \end{align*}\)

解密过程可看作**系数为\((d_0, d_1, d_2)\)的二阶多项式在横坐标s处的求值**。

**存在问题**

私钥\(\mathbf{s}\)扩展为新私钥\(\mathbf{s} \otimes \mathbf{s}\)，每进行 1 次同态乘法，私钥需扩展 1 次；若进行n次同态乘法，密文与私钥需外积n次，最终导致**密文与私钥维度爆炸**。

**解决方案**：将\(s^2\)加密到s下，实现二次项转一次项

具体流程：

令消息\(m = s^2\)，则向量\(\mathbf{m} = (s^2, 0)\)。选择随机数\(r, e_0, e_1 \in \chi\)，加密过程如下：

\(\mathbf{c} = \mathbf{m} + 2(e_0, e_1) + \mathbf{a} r = (s^2, 0) + 2(e_0, e_1) + (b, -a') r = (s^2 + 2e_0 + b r, -(a' r - 2e_1)) \approx (s^2 + \alpha s, -\alpha) = (\beta, -\alpha)\)

其中，\(\alpha = a' r - 2e_1\)，且：

\(s^2 + 2e_0 + b r = s^2 + 2e_0 + (a' s + 2e) r = s^2 + 2e_0 + a' s r + 2e r \approx s^2 + a' r s - 2e_1 s = s^2 + \alpha s\)

（仅去掉了\(2e_0\)，因其规模极小可近似忽略）

由此可得\(s^2 = \beta - \alpha s\)，即通过**评估密钥evk**，可将扩展密文\((d_0, d_1, d_2)\)转换为正常密文\((\bar{c}_0, \bar{c}_1)\)：

\(d_0 + d_1 s + d_2 s^2 = d_0 + d_1 s + d_2 (\beta - \alpha s) = \bar{c}_0 + \bar{c}_1 s = \langle (\bar{c}_0, \bar{c}_1), (1, s) \rangle = \langle \bar{\mathbf{c}}, \mathbf{s} \rangle\)

**密文与密钥的对应关系**

- 扩展密文：\(\mathbf{c} \otimes \mathbf{c}' = (c_0, c_1) \otimes (c_0', c_1') = (d_0, d_1, d_2)\)，对应扩展私钥\(\mathbf{s} \otimes \mathbf{s} = (1, s, s^2)\)；
- 正常密文：\((\bar{c}_0, \bar{c}_1)\)，对应正常私钥\(\mathbf{s} = (1, s)\)。

因此，**密钥交换 / 再线性化技术将扩展密文转换为正常密文，确保解密密钥保持不变**。







##### 核心技术：模交换

**同态乘法**

\(\begin{align*} \mathbf{c} \otimes \mathbf{c}' &= (c_0, c_1) \otimes (c_0', c_1') = (c_0c_0',\ c_0c_1',\ c_1c_0',\ c_1c_1') \\ &= (m + 2e_0 + br)(m' + 2e_0' + br') + (m + 2e_0 + br)(2e_1' - a'r') \\ &\quad + (m' + 2e_0' + br')(2e_1 - a'r) + (2e_1 - ar)(2e_1' - a'r') \end{align*}\)

噪声为\((r, e_0, e_1),\ (r', e_0', e_1') \in \chi\)

**存在问题**

有两个噪声值为\(\|\chi\|\)的密文，相乘后噪声近似为\(\|\chi\|^2\)，则经过\(\log k\)层同态乘法，噪声积累就达到上限\(\|\chi\|^k \mod q\)，无法继续运算。

**举例**：若优质基为 100，噪声\(\|\chi\| \leq 7\)，则\(7^2 = 49 \leq 50\)，仅支持 1 次乘法运算；若进行 2 次乘法运算，\(7^3 \geq 50\)会因四舍五入出错。

**解决方案**

每次同态乘法后对密文乘以\(1/\|\chi\|\)，将噪声降低为\(\|\chi\|\)，同时模缩减为\(q/\|\chi\|\)。

通过模缩减，每缩减i次模，可进行\(\log^{k-i}\)层同态乘法运算，最后差不多可以进行k-1次乘法，相比原方案仅能进行\(\log k\)层的限制，层数实现指数级提高。

这使得 BGV 可以在不进行自举的情况下，执行预定深度的电路（Leveled FHE）

##### FV12

[Somewhat Practical Fully Homomorphic Encryption](https://eprint.iacr.org/2012/144.pdf)

令\(R = \mathbb{Z}[x]/\langle x^d + 1 \rangle\)（其中d是 2 的幂）。令q和p为正整数，放大因子\(\Delta = \lfloor q/p \rfloor\)，\(r_t(q) = q \mod p\)。对于任何自然数t，令\(R_t = \mathbb{Z}_t[x]/\langle x^d + 1 \rangle\)。令\(\chi\)是\(R_q\)上的B有界概率分布。

**密钥生成**

- 输入安全参数\(\lambda\)，输出小的随机数作为私钥\(sk = s \in \chi\)。
- 选择随机数\(a \in R_q\)，计算\(-(a \cdot s + e) \mod q\)（其中\(e \in \chi\)是噪声）。
- 输出私钥\(sk = s \in \chi\)和公钥\(pk = (p_0, p_1) = (-(a \cdot s + e) \mod q, a)\)。

**加密**

输入消息\(m \in R_p\)和公钥\(pk \in R_q^2\)，选择小的随机数\(u, e_1, e_2 \in \chi\)，计算：

\(\begin{align*} c_0 &= (p_0 \cdot u + e_1 + \Delta \cdot m) \mod q, \\ c_1 &= (p_1 \cdot u + e_2) \mod q \end{align*}\)

输出密文\(\mathbf{c} = (c_0, c_1)\)。

**解密**

输入秘密密钥\(s \in R_q\)和密文\(\mathbf{c} \in R_q^2\)，解密公式：

\(m = \left\lfloor \frac{p \cdot (c_0 + c_1 \cdot s) \mod q}{q} \right\rfloor \mod p\)

**公式展开**：

\(\begin{align*} \frac{p \cdot (c_0 + c_1 \cdot s) \mod q}{q} &= \frac{p \cdot (p_0 \cdot u + e_1 + \Delta \cdot m + p_1 \cdot u \cdot s + e_2 \cdot s) \mod q}{q} \\ &= \frac{p \cdot (-(a \cdot s + e) \cdot u + e_1 + \Delta \cdot m + a \cdot u \cdot s + e_2 \cdot s) \mod q}{q} \\ &= \frac{p \cdot (\Delta \cdot m + e \cdot u + e_1 + e_2 \cdot s) \mod q}{q} \\ &= \frac{q \cdot m + p \cdot (e \cdot u + e_1 + e_2 \cdot s) \mod q}{q} \\ &= m + \frac{p \cdot (e \cdot u + e_1 + e_2 \cdot s) \mod q}{q} \end{align*}\)

**同态加法**

密文加法：\(\mathbf{c} + \mathbf{c}' = (c_0 + c_0',\ c_1 + c_1') = (c_0'',\ c_1'')\)

**解密验证**：

\(\begin{align*} \left\lfloor \frac{p \cdot (c_0'' + c_1'' \cdot s) \mod q}{q} \right\rfloor \mod p &= \left\lfloor \frac{p \cdot ((c_0 + c_0') + (c_1 + c_1') \cdot s) \mod q}{q} \right\rfloor \mod p \\ &= \left\lfloor \frac{p \cdot (p_0 \cdot u + e_1 + \Delta \cdot m + p_1 \cdot u \cdot s + e_2 \cdot s + p_0 \cdot u' + e_1' + \Delta \cdot m' + p_1 \cdot u' \cdot s + e_2' \cdot s) \mod q}{q} \right\rfloor \mod p \\ &= \left\lfloor \frac{p \cdot (-(a \cdot s + e)(u + u') + (e_1 + e_1') + \Delta \cdot (m + m') + a \cdot (u + u') \cdot s + (e_2 + e_2') \cdot s) \mod q}{q} \right\rfloor \mod p \\ &= \left\lfloor \frac{p \cdot (\Delta \cdot (m + m') + e \cdot (u + u') + (e_1 + e_1') + (e_2 + e_2') \cdot s) \mod q}{q} \right\rfloor \mod p \\ &= \left\lfloor \frac{q \cdot (m + m') + p \cdot (e \cdot (u + u') + (e_1 + e_1') + (e_2 + e_2') \cdot s) \mod q}{q} \right\rfloor \mod p \\ &= (m + m') + \left\lfloor \frac{p \cdot (e \cdot (u + u') + (e_1 + e_1') + (e_2 + e_2') \cdot s) \mod q}{q} \right\rfloor \mod p \end{align*}\)

**同态乘法**

密文乘法：\(\mathbf{c} \otimes \mathbf{c}' = (c_0c_0',\ c_0c_1',\ c_1c_0',\ c_1c_1')\)

**解密特性**：两个密文的乘积对应**二阶多项式**，最终通过**密钥交换 / 再线性化**降阶：

\(\begin{align*} c(s) \cdot c'(s) &= (c_0 + c_1 \cdot s)(c_0' + c_1' \cdot s) \\ &= c_0c_0' + (c_0c_1' + c_1c_0')s + c_1c_1' \cdot s^2 \\ &= a_0 + a_1 \cdot s + a_2 \cdot s^2 \\ &= \beta_0 + \beta_1 \cdot s \end{align*}\)

##### LTV13

[On-the-fly multiparty computation on the cloud via multikey fully homomorphic encryption](https://eprint.iacr.org/2013/094.pdf)

- **密钥生成**：选择两个小的随机多项式 \(f', g \in \chi\)。其中，\(\chi\) 是 \(R = \mathbb{Z}[x]/\langle x^d + 1 \rangle\) 上的 B 有界分布，且 d 是 2 的幂。私钥为 \(f = 2f' + 1 \in R\)。其中，\(f \equiv 1 \mod 2\)，且 f 在 \(R_q\) 中是可逆的。公钥为 \(h = 2g f^{-1} \mod q \in R_q\)。

-  **加密**：输入消息为 \( m \in \mathbb{F}_2 \)（二元有限域），随机小（噪声）元素 \(r, e \in \chi\)，如下计算

  \(c = m + h r + 2e \in R_q\)

  则密文 c 是卷积多项式环 \(R_q = \mathbb{Z}_q[x]/\langle x^d + 1 \rangle\) 中的一个元素。

- **解密**：输入私钥 f 和密文 c，如下解密

  \(\begin{align*}  (f c \mod q) \mod 2 &= f(m + h r + 2e) \mod q \mod 2 \\  &= f m + f h r + 2 f e \mod q \mod 2 \\  &= f m + 2(g r + f e) \mod q \mod 2 \\  &= f m + 2v \mod q \mod 2 \\  &= (2f' + 1)m + 2v \mod 2 \\  &= m  \end{align*}\)

存在一个关键等式：

​	\(f c = m f + 2v \in R_q\)

##### 核心技术：提升维数 

上述环 LEW 加密方案中，私钥的维数为 \( k \)，令 \( \ell = \lceil \log q \rceil \)。其中，\( q \) 是加密方案的模，则 \( \text{Powersof2}(sk) \) 的维数为 \( k\ell \)。

- **加密**：消息为 \( m \in \mathbb{F}_2 \)，如下加密：  

  \[  \mathbf{c}_{1,1} := \text{Enc}_{\text{pk}}(m, 0, \dots, 0),\ \dots,\ \mathbf{c}_{1,\ell} := \text{Enc}_{\text{pk}}(m \cdot 2^{\ell-1}, 0, \dots, 0)  \]  \[  \mathbf{c}_{2,1} := \text{Enc}_{\text{pk}}(0, m, 0, \dots, 0),\ \dots,\ \mathbf{c}_{2,\ell} := \text{Enc}_{\text{pk}}(0, m \cdot 2^{\ell-1}, 0, \dots, 0)  \]  \[  \dots  \]  \[  \mathbf{c}_{k,1} := \text{Enc}_{\text{pk}}(0, \dots, 0, m),\ \dots,\ \mathbf{c}_{k,\ell} := \text{Enc}_{\text{pk}}(0, \dots, 0, m \cdot 2^{\ell-1})  \]  

  则密文是 \( k\ell \times k \) 的矩阵。 

- **解密**：使用私钥对密文矩阵中的某个密文解密即可。

##### LTV13：维数提升+位展开

- **加密**：输入消息为 \( m \in \mathbb{F}_2 \)，随机小（噪声）元素 \( r_i, e_i \in \chi \)，计算
  \[
  c_i = m \cdot 2^i + h r_i + 2 e_i \in R_q
  \]
  则密文 \( \mathbf{c} = (c_1, \dots, c_\ell) \in R_q^\ell \)。

- **解密**：输入私钥 \( f \) 和密文第一项 \( c_1 \)，推导如下
  \[
  \begin{align*}
  (f c_1 \mod q) \mod 2 &= f(m + h r_1 + 2 e_1) \mod q \mod 2 \\
  &= f m + f h r_1 + 2 f e_1 \mod q \mod 2 \\
  &= f m + 2(g r_1 + f e_1) \mod q \mod 2 \\
  &= f m + 2 v \mod q \mod 2 \\
  &= (2f^2 + 1) m + 2 v \mod 2 \\
  &= m
  \end{align*}
  \]

存在**关键等式**：
\[
f c_1 = m f + 2 v \in R_q
\]

对关键等式一般化：
\[
f \mathbf{c} = (c_1 f, \dots, c_\ell f)^T = (m f + 2 v, \dots, m \cdot 2^{\ell-1} f + 2 v) = m \cdot \text{Powersof2}(f)^T + 2 v \in R_q
\]

- **同态加法**：若 \( \mathbf{c} + \mathbf{c}' \in R_q^\ell \)，先忽略 \( \mod q \mod 2 \)，则
  \[
  \begin{align*}
  f(\mathbf{c} + \mathbf{c}') &= f \mathbf{c} + f \mathbf{c}' \\
  &= (m \cdot \text{Powersof2}(f)^T + 2 v) + (m' \cdot \text{Powersof2}(f)^T + 2 v') \\
  &= (m + m') \cdot \text{Powersof2}(f)^T + 2 v + 2 v' mod2\\
  &= m+m'
  \end{align*}
  \]
  注意ltv13已经定义，\(f \equiv 1 \mod 2\)
  
- **同态乘法**：若 \( \text{BitDecomp}(\mathbf{c}) \cdot \mathbf{c}' \in R_q^\ell \)，解密推导如下
  \[
  \begin{align*}
  (\text{BitDecomp}(\mathbf{c}) \cdot \mathbf{c}') f &= \text{BitDecomp}(\mathbf{c}) \cdot (m' \cdot \text{Powersof2}(f)^T + 2 v') \\
  &= m' \mathbf{c} f + 2 v' \text{BitDecomp}(\mathbf{c}) \\
  &= m'(m \cdot \text{Powersof2}(f)^T + 2 v) + 2 v' \text{BitDecomp}(\mathbf{c}) \\
  &= m m' \cdot \text{Powersof2}(f)^T + 2 m v' + 2 v' \text{BitDecomp}(\mathbf{c}) mod 2\\
  &= mm'
  \end{align*}
  \]
  当噪声与密文 \( \mathbf{c} \) 或私钥 \( s \) 相关时，使用 \( \text{BitDecomp}(\mathbf{c}) \) 或 \( \text{BitDecomp}(s) \) 减小噪声影响。
  
  就是通过**升维拆分 + 二进制表示**，让原本集中在单个密文元素上的噪声被 “分摊” 和 “弱化”，从而使得噪声对每个密文分量的影响显著降低。

#### 第 3 代：基于 LWE 和 RLWE

##### GSW13

[Homomorphic Encryption from Learning with Errors:Conceptually-Simpler, Asymptotically-Faster, Attribute-Based](https://eprint.iacr.org/2013/340.pdf)

安全参数为\(\lambda\)，电路深度为L。模为q、噪声分布\(\chi\)、维数n以及m。其中，分布\(\chi\)是\( \mathbb{Z}\)上的噪声高斯分布，\(m = n\log q\)。令\(l = \lfloor \log q \rfloor +1\)，\(N = (n + 1)l\)。

**密钥生成**

- 选择随机向量\(\mathbf{s}' \leftarrow \mathbb{Z}_q^n\)，私钥为\(sk = \mathbf{s} = (1, \mathbf{s}') \in \mathbb{Z}_q^{n+1}\)。有以下等式成立：

  \(\text{Powerof2}(\mathbf{s}) = (\mathbf{s}, 2\mathbf{s}, \cdots, 2^{l-2}\mathbf{s}) \mod q = (1, 2, \cdots, 2^{l-2}, \mathbf{s}', 2\mathbf{s}', \cdots, 2^{l-2}\mathbf{s}') \mod q\)

- 选取随机矩阵\(\mathbf{A}' \leftarrow \mathbb{Z}_q^{m \times n}\)和噪声向量\(\mathbf{e} \leftarrow \chi^m\)，计算

  \(\mathbf{b} := \mathbf{A}' \cdot \mathbf{s}' + \mathbf{e}\)

- 令\(\mathbf{A}\)为\(n+1\)列矩阵，由向量\(\mathbf{b}\)和矩阵\(\mathbf{A}'\)构成

  \(\mathbf{A} = [\mathbf{b} \mid -\mathbf{A}'] \in \mathbb{Z}_q^{m \times (n+1)}\)

- 公钥为\(pk = \mathbf{A}\)。

**注意等式**

\(\mathbf{A} \cdot \mathbf{s} = [\mathbf{b} \mid -\mathbf{A}'] \cdot (1, \mathbf{s}')^T = (\mathbf{A}' \cdot \mathbf{s}' + \mathbf{e}) - \mathbf{A}' \cdot \mathbf{s}' = \mathbf{e}\)

**加密**

- 消息为\( m \in \{0,1\} \)，选取随机矩阵\(\mathbf{R} \in \{0,1\}^{N \times m}\)，加密版：

  \(C = \text{Flatten}(m \cdot I_N + \text{BitDecomp}(\mathbf{R} \cdot \mathbf{A}))\)

  其中，\(I_N\)是\(N \times N\)的单位矩阵

**MPDEC解密(具体看MP12)**

- 输入私钥\(\mathbf{s}\)和密文C，如下计算：

  \(C \cdot \text{Powerof2}(\mathbf{s}) = \text{Flatten}(m \cdot I_N + \text{BitDecomp}(\mathbf{R} \cdot \mathbf{A})) \cdot \text{Powerof2}(\mathbf{s}) = m \cdot I_N \text{Powerof2}(\mathbf{s}) + \mathbf{R} \mathbf{e} = m \cdot \text{Powerof2}(\mathbf{s}) + \mathbf{e}'\)

  取出m，\(\mathbf{R} \cdot \mathbf{e} = \mathbf{e}' \approx 0\)。
  
  MPDec(params, sk, C) (for q a power of 2): Observe that \(q = 2^{\ell-1}\) and the first \(\ell-1\) coefficients of \(\vec{v}\) are \(1, 2, \ldots, 2^{\ell-2}\), and therefore if \(C \cdot \vec{v} = \mu \cdot \vec{v} + \text{small}\), then the first \(\ell-1\) coefficients of \(C \cdot \vec{v}\) are \(\mu \cdot \vec{g} + \text{small}\), where \(\vec{g} = (1, 2, \ldots, 2^{\ell-2})\). Recover \(\text{LSB}(\mu)\) from \(\mu \cdot 2^{\ell-2} + \text{small}\), then recover the next-least-significant-bit from \((\mu - \text{LSB}(\mu)) \cdot 2^{\ell-3} + \text{small}\), etc. (See [MP12] for the general q case.)

**同态加法：**

\(C + C' = \text{Flatten}((m + m') \cdot I_N + (\mathbf{R} + \mathbf{R}') \cdot \mathbf{A})\)

- **解密**：

  \((C + C')\mathbf{s} = (m + m') \cdot I_N \mathbf{s} + (\mathbf{R} + \mathbf{R}')\mathbf{e} = (m + m') \cdot \text{Powerof2}(\mathbf{s}) + (\mathbf{R} + \mathbf{R}')\mathbf{e}\)

**同态乘法：化简版**

\(C \cdot C' = (m \cdot I_N + \mathbf{R} \cdot \mathbf{A}) \cdot (m' \cdot I_N + \mathbf{R}' \cdot \mathbf{A})\)

**论文版\(\text{Flatten}(C \cdot C')\)**

- **解密**：

  由前面的解密步骤可知\(C \cdot \mathbf{s} = m \cdot \text{Powerof2}(\mathbf{s}) + \mathbf{e}'\)，所以如下解密：\((C \cdot C')\mathbf{s} = C \cdot (m' \cdot \text{Powerof2}(\mathbf{s}) + \mathbf{e}') = m'C \cdot \text{Powerof2}(\mathbf{s}) + C \cdot \mathbf{e}' = m'(m \cdot \text{Powerof2}(\mathbf{s}) + \mathbf{e}') + C \cdot \mathbf{e}' = m'm\text{Powerof2}(\mathbf{s}) + m'\mathbf{e}' + C \cdot \mathbf{e}'\)当\(m'\mathbf{e}' + C \cdot \mathbf{e}' \leq (N + 1)^2 E = ((n + 1)l + 1)^2 \cdot 2n \log q E\)时，可解密成功。

  经过深度为L的电路计算后，结果密文的噪声至多为\((N + 1)^L E\)。因此，需满足以下条件才能正确解密：

  \((N + 1)^L E = ((n + 1)l + 1)^L \cdot 2n \log q E \ll q/8\)

**GSW 方案的主要缺点**

GSW 方案的主要缺点是较高的通信成本（密文相对于对应的明文较大）和计算复杂性。为了减少计算开销，提出了各种优化方法以改进同态过程。

##### TRLWE18

[TFHE: Fast Fully Homomorphic Encryption over the Torus](https://eprint.iacr.org/2018/421.pdf)

令 \(R = \mathbb{Z}[x]/\langle x^d + 1 \rangle\)。其中，d 是 2 的幂次方。令 \(T = \mathbb{R}[x]/\langle x^d + 1 \rangle \mod 1; \mathbb{R}实数集,系数在(-1/2,1/2]\) 和 \(R_2 = \mathbb{F}_2[x]/\langle x^d + 1 \rangle\)，即 \(R_2\) 中的任何元素都是具有二进制系数的 R 中的多项式。

- **密钥生成**：输入安全参数 \(\lambda\)，输出小的私钥 \(\mathbf{s} \in R_2^n\)。

- **加密**：输入私钥 \(\mathbf{s} \in R_2^n\)，消息 \(m \in T , m_i \in \lbrace 0,1/2\rbrace或者联系[0,1)\)。选择一个均匀随机的掩码 \(\mathbf{a} \in T^n\)，并选择一个噪声 \(e \in \chi,e_i \in ( -1/4,1/4 )且期望=0\)。其中，\(\chi\) 是一个 B 有界分布，则密文为：

  \(\mathbf{c} := (\mathbf{a}, b) = (\mathbf{a}, \mathbf{s} \cdot \mathbf{a} + m + e) \in T^n \times T\)

  其中$\mathbf{s} \cdot \mathbf{a}$是内积，s1·a1+s2·a2+...+sn·an，n个多项式相乘，时间复杂度ndlogd

- **解密**：输入私钥 \(\mathbf{s} \in R_2^n\) 和密文 \(\mathbf{c} \in T^{n+1}\)，计算密文 \( \mathbf{c} \) 的秘密线性 \(\kappa\)-Lipschitz 函数 \(\varphi_s\)（称为**相位**）。该相位 \(\varphi_s: T^n \times T \to T\) 满足：

  \(\varphi_s(\mathbf{a}, b) = b - \mathbf{s} \cdot \mathbf{a}\)

  注意，该函数由私钥 \(\mathbf{s} \in R_2^n\) 参数化。相位 \(\varphi_s(\mathbf{c})\) 接近实际的消息：

  \(\varphi_s(\mathbf{c}) = \mathbf{s} \cdot \mathbf{a} + m + e - \mathbf{s} \cdot \mathbf{a} = m + e\)

  最后，将 \(\varphi_s(\mathbf{c})\) 舍入到消息空间 \(M \subset T\) 中的最近点。

  - 若 \(m = 0\)，则 \(m + e \in (-1/4, 1/4)\)，模 1 后仍落在 \([0, 1/4) \cup (3/4, 1)\)，解码为 0；
  - 若 \(m = 1/2\)，则 \(m + e \in (1/2 - 1/4, 1/2 + 1/4) = (1/4, 3/4)\)，解码为 1。

- **（同态加法）密文的线性组合**：设 \(\mathbf{c}_1, \dots, \mathbf{c}_p\) 为 p 个独立的密文，具有相同的密钥 \(\mathbf{s}\)，并且设 \(f_1, \dots, f_p\) 为 R 中的整数多项式（作为权重）。如下构造线性组合的密文：

  \(\mathbf{c} = \sum_{i=1}^p f_i \cdot \mathbf{c}_i\)

  要求误差幅度保持小于 \(1/4\)，即 \(\|e\|_\infty \leq 1/4\)。

- **解密（线性组合）**：

  \(\text{Dec}_s(\mathbf{c}) = \sum_{i=1}^p f_i \cdot \text{Dec}_s(\mathbf{c}_i)\)

  密文可以线性组合，从而得到一个新的密文，解密后可以获得明文的线性组合。

  **同态乘法**

- <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251122171957338.png" alt="image-20251122171957338" style="zoom:80%;" />

**Gadget分解**，将TLWE样本（带噪声的加密数据）分解为符合 “gadget 矩阵”（用于后续同态运算的基础结构）要求的向量形式，为 TLWE 与 TGSW 的外部乘积（⊡，）、电路引导（）等核心同态操作提供输入，同时严格控制分解误差以保证后续运算的正确性。

**TGSW样本**

TGSW 是**环上 GSW 变体**，由(k+1)l行 TLWE 密文组成，是 TLWE 与 TGSW 外部乘积（同态乘法）的核心输入。

构造步骤

1. **生成 Homogeneous TLWE 矩阵Z**

   每行是**加密 0 的 TLWE 样本**：(*a*,*b*)=(*a*,*s*⋅*a*+*e*)，其中*a*均匀采样，*e*来自模高斯分布*D*T*N*[*X*],*α*，*s*为 TLWE 私钥。

2. **计算明文项μ·H**

   明文*μ*∈R（整数多项式环）与 Gadget 矩阵H做矩阵乘法。

3. **组合生成 TGSW 样本**C*=*Z*+*μ*⋅*H，逐行相加后，每行是含噪声的 TLWE 密文，加密明文μ。

**外部乘积**

* **环与空间**：


  * $  R = \mathbb{Z}[x]/(x^d+1)  $，$  d  $为 2 的幂次（反循环多项式环，整数系数）；

  * $  T = \mathbb{R}[x]/(x^d+1) \mod 1  $（实数环面，系数范围$  (-1/2, 1/2]  $）；

  * $  R_2 = \mathbb{F}_2[x]/(x^d+1)  $（二进制系数的$  R  $中多项式环，私钥空间）；

* **TLWE 密文**：$  c = (a, b) \in T^n \times T  $，其中$  a  $是随机掩码，$  b = s \cdot a + m + e  $（$  s \in R_2^n  $为私钥，$  m \in T  $为明文，$  e \in \chi  $为噪声，$  \chi  $是 B - 有界分布，$  e_i \in (-1/4, 1/4)  $）；

* **TGSW 样本**：由$  (k+1)\ell  $行 TLWE 密文组成的矩阵，加密明文$  \mu_A \in R  $，形式为$  A = Z_A + \mu_A \cdot H  $（$  Z_A  $是加密 0 的噪声矩阵，$  H  $为 Gadget 矩阵）；

* **Gadget 矩阵**：块对角结构，元素为$  \frac{1}{B_g}, \frac{1}{B_g^2}, \dots, \frac{1}{B_g^\ell}  $（$  B_g  $为分解基，$  \ell  $为分解层数），维度$  (k+1)\ell \times (k+1)  $。

**外部乘积的定义（Definition 3.12）**

外部乘积是**TGSW 样本与 TLWE 样本的同态运算**，符号为⊡，定义为：

$  (A, b) \mapsto A \boxminus b = Dec_{H, \beta, \epsilon}(b) \cdot A  $

* 输入：$  A \in \text{TGSW}  $（TGSW 样本），$  b \in \text{TLWE}  $（TLWE 样本）；

* 输出：$  A \boxminus b \in \text{TLWE}  $（新的 TLWE 样本，加密明文$  \mu_A \cdot \mu_b  $）；

* $  Dec_{H, \beta, \epsilon}(b)  $：对 TLWE 样本$  b  $执行 Gadget 分解（Algorithm 1），得到小整数向量$  u \in R^{(k+1)\ell}  $（满足$  \|u\|_\infty \leq \beta = B_g/2  $，$  \|u \cdot H - b\|_\infty \leq \epsilon = 1/(2B_g^\ell)  $）。

**运算过程与明文映射**

设$  u = Dec_{H, \beta, \epsilon}(b) \in R^{(k+1)\ell}  $，TGSW 样本$  A = Z_A + \mu_A \cdot H  $（$  Z_A  $是加密 0 的噪声矩阵，$  \mu_A  $是 TGSW 明文），则外部乘积的展开式为：

$ 
\begin{align*}
A \boxminus b &= u \cdot A \\
&= u \cdot Z_A + \mu_A \cdot (u \cdot H) \\
\end{align*}
 $

由 Gadget 分解的性质（$  u \cdot H = b + \epsilon_{\text{dec}}  $，$  \|\epsilon_{\text{dec}}\|_\infty \leq \epsilon  $），进一步展开：

$ 
\begin{aligned} A \boxminus b & =u \cdot Z_{A}+\mu_{A} \cdot\left(b+\epsilon_{dec}\right) \\ & =u \cdot Z_{A}+\mu_{A} \cdot \epsilon_{dec}+\mu_{A} \cdot z_{b}+\left(0, \mu_{A} \cdot \mu_{b}\right) . \end{aligned}
 $

其中$  \mu_b  $是 TLWE 样本$  b  $的明文（$  b = s \cdot a + \mu_b + e  $，$ e $为 TLWE 噪声）。

**明文乘积的验证**

对输出的 TLWE 样本计算**相位函数**$  \varphi_s  $（TLWE 的解密核心函数，$  \varphi_s(c) = b - s \cdot a  $）：

$ 
\varphi_s(A \boxminus b) = u \cdot \text{Err}(A) + \mu_A \cdot \varphi_s(\epsilon_{\text{dec}}) + \mu_A \cdot \text{Err}(b) + \mu_A \mu_b
 $

取期望后，明文项为$  \mu_A \mu_b  $，即：

$ 
\text{msg}(A \boxminus b) = \mu_A \cdot \mu_b
 $

这验证了外部乘积的**同态性**—— 密文运算对应明文乘积。

**噪声控制**

外部乘积的噪声幅度需满足$  \| \text{Err}(A \boxminus b) \|_\infty \leq 1/4  $（确保 TLWE 解密正确），其噪声由三部分组成：

1. $  u \cdot \text{Err}(A)  $：TGSW 样本$  A  $的噪声经$  u  $加权后的贡献；

2. $  \mu_A \cdot \varphi_s(\epsilon_{\text{dec}})  $：Gadget 分解误差$  \epsilon_{\text{dec}}  $的贡献；

3. $  \mu_A \cdot \text{Err}(b)  $：TLWE 样本$  b  $的噪声经$  \mu_A  $加权后的贡献。

结合参数约束（如$  B_g, \ell, \alpha  $的选择），可保证总噪声幅度$  \leq 1/4  $，具体边界为：

$ 
\| \text{Err}(A \boxminus b) \|_\infty \leq (k+1)\ell N \beta \|\text{Err}(A)\|_\infty + \|\mu_A\|_1 (1 + kN) \epsilon + \|\mu_A\|_1 \|\text{Err}(b)\|_\infty
 $



**内部乘积（⊠）**（可以不看，反正外部乘积基本可以取代内部乘积）

**内部乘积**是 TGSW 样本的同态乘法，实现明文多项式乘积$\mu_A \cdot \mu_B$。公式定义如下：

$A \otimes B = 
\begin{bmatrix} 
A \boxminus b_1 \\ 
A \boxminus b_2 \\ 
\vdots \\ 
A \boxminus b_{(k+1)\ell} 
\end{bmatrix}
\quad \text{其中} \quad 
b_i = \mu_B \cdot h_i + \text{noise}也就是(a)$

* $A, B$：TGSW 样本，明文分别为$\mu_A, \mu_B \in \mathbb{Z}[x]/(x^d+1)$

* $h_i$：Gadget 矩阵第$i$行（结构：$1/B_g^1, 1/B_g^2, \dots, 1/B_g^\ell$）

* **关键逻辑**：每行执行外部乘积$A \boxminus b_i$，输出新 TGSW 样本，明文为$\mu_A \cdot \mu_B$

$A \boxminus b_i = u_i \cdot (Z_A + \mu_A H) = u_i \cdot Z_{A}+\mu_{A} \cdot\left(b+\epsilon_{dec}\right) = u_i \cdot Z_{A}+\mu_{A} \cdot \epsilon_{dec}+\mu_{A} \cdot z_{b}+\left(0, \mu_{A} \cdot \mu_{b} \cdot h_i\right) $

* $u_i$：Gadget 分解向量（$\|u_i\|_\infty \leq B_g/2$）
* 噪声项：$u_i \cdot Z_A + \mu_A \cdot \epsilon_{\text{dec}}$（需满足$  \leq 1/4  $）



#### 第 4 代：基于 LWE 和 RLWE

##### 核心技术：重缩放

**问题背景：数据的膨胀（而非噪声）** CKKS 是为了处理实数（近似计算）设计的。在计算机中，小数通常表示为整数乘以一个比例因子（Scale, $\Delta$）。 例如：$3.14$ 存为 $314$ ($\Delta = 100$)

当你做同态乘法时：

- $m_1$ (Scale $\Delta$) $\times$ $m_2$ (Scale $\Delta$) $=$ $m_1 \cdot m_2$ (Scale $\Delta^2$)。
- 比如 $3.14 \times 2.00 \to 314 \times 200 = 62800$。这个数对应的 Scale 是 $10000$，还原回去是 $6.28$。

如果在同态加密中连续相乘，这个 Scale $\Delta^n$ 会迅速爆炸，导致有效数据溢出模数。

CKKS 的重缩放利用了和 BGV 模交换类似的数学机制，但目的完全不同。

- **操作：** 将密文除以一个整数（通常就是 Scale $\Delta$），同时也把模数链中的模数 $Q$ 除以 $\Delta$。
- **结果：** 密文中的消息 $m \cdot \Delta^2$ 变成了 $m \cdot \Delta$。
- **意义：** 它去掉了乘法产生的小数点后多余的精度，将数据的 Scale 恢复到初始水平 $\Delta$，防止数据本身数值过大。同时，它也像模交换一样顺便压缩了噪声,而且还**缩减了明文的长度**。

**重缩放的具体流程**

重缩放是将高 Level 密文转换为低 Level 密文的确定性算法，输入为 Level $\ell$的密文$c$，输出为 Level $\ell'$（$\ell' < \ell$）的密文$c'$，步骤如下：

**(1) 输入**

- Level $\ell$的密文：$(c, \ell, \nu, B) \in R_{q_\ell}^2 \times \{0, \dots, L\} \times \mathbb{R} \times \mathbb{R}$，满足
  $$\langle c, sk \rangle \equiv m + e \pmod{q_\ell};$$
- 目标 Level：$\ell' < \ell$（通常取$\ell' = \ell - 1$，即每次重缩放降低 1 个 Level）。

**(2) 核心计算**

重缩放通过“模数比例缩放 + 系数取整”生成新密文$c'$，公式为：
$$c' = \left\lfloor \frac{q_{\ell'}}{q_\ell} \cdot c \right\rceil \pmod{q_{\ell'}}$$

- $\frac{q_{\ell'}}{q_\ell}$：缩放因子，因$q_\ell = p^\ell q_0$、$q_{\ell'} = p^{\ell'} q_0$，故$\frac{q_{\ell'}}{q_\ell} = p^{\ell' - \ell}$（如$\ell' = \ell - 1$时，缩放因子为$p^{-1}$）；
- $\lfloor \cdot \rceil$：“最近整数取整”（tie 时向上取整），作用是将“非整数系数的中间结果”离散化为分圆环$R_{q_{\ell'}}$中的元素；
- $(\mod q_{\ell'})$：将新密文限制在目标 Level 的模数空间内，保证后续同态操作的兼容性。

**(3) 输出与新标签信息**

输出 Level $\ell'$的有效密文$(c', \ell', \nu', B')$，其中标签信息更新规则由论文表 1 明确：

- 新明文上界：$\nu' = p^{\ell' - \ell} \cdot \nu$（明文缩放因子同比缩小）；
- 新噪声上界：$B' = p^{\ell' - \ell} \cdot B + B_{\text{scale}}$（$B_{\text{scale}}$为重缩放引入的“舍入误差上界”，论文 Lemma 2 证明$B_{\text{scale}} = \sqrt{N/3} \cdot (3 + 8\sqrt{h})$，$N = \phi(M)$为分圆多项式度数，$h = 64$为私钥汉明重量）。

**重缩放后的解密结构变化**

重缩放的核心是“维持解密结构的有效性”——新密文$c'$仍能正确加密“缩放后的明文”
$$\langle c', sk \rangle \equiv \frac{q_{\ell'}}{q_\ell} \cdot m + \left( \frac{q_{\ell'}}{q_\ell} \cdot e + e_{\text{scale}} \right) \pmod{q_{\ell'}}$$

- 核心含义：新密文加密的明文是$m' = \frac{q_{\ell'}}{q_\ell} \cdot m = p^{\ell' - \ell} \cdot m$（如$\ell' = \ell - 1$时，明文缩小为$m/p$）；
- 新噪声组成：
  1. 原始噪声缩放项：$\frac{q_{\ell'}}{q_\ell} \cdot e$（随明文同比缩小，截断噪声的 LSB）；
  2. 舍入误差项：$e_{\text{scale}} = \langle \tau, sk \rangle$（$\tau = c' - \frac{q_{\ell'}}{q_\ell} \cdot c$为取整残留，其范数被$B_{\text{scale}}$严格约束）。

该结构确保：重缩放后，噪声仍远小于明文（$B' \ll \nu'$），解密结果仍是“明文的近似值”，符合方案“近似算术”的设计目标。



##### CKKS16近似数算术的同态加密

[Homomorphic Encryption for Arithmetic of Approximate Numbers](https://eprint.iacr.org/2016/421.pdf)

令 \(R = \mathbb{Z}[x]/\langle x^d + 1 \rangle\) 且 \(d = 2^M\)。对于基数 p（控制缩放比例$2^30 or 2^56$）、模 \(q_0\) 和自然数 L（选择的层次），令 \(q_\ell = p^\ell \cdot q_0\) 对于 \(\ell = 1, \ldots, L\)。注意，层次 \(\ell\)的密文是 $R_{q\ell}$ 中的一个向量。考虑以下相关分布：对于实数 \(\sigma\)，\(DG(\sigma^2)\) 是一个在 \(\mathbb{Z}^d\) 上的离散高斯分布，从独立的离散高斯分布中采样，每个分量的方差为 \(\sigma^2\)。对于 \(0 < \rho < 1\) 的实数，随机掩码分布 \(ZO(\rho)\) 是一个在 \(\{-1, 0, 1\}^d\) 上的分布。其中，0 的概率为 \(1 - \rho\)，而 -1 或 1 的概率为 \(\frac{\rho}{2}\)。最后，\(\chi\) 是一个 B- 有界分布（噪声空间）。

**层次型 CKKS16 方案构造如下：**

- **密钥生成**：输入安全参数 \(\lambda\)，选择$M（d=2^M）$,整数 h(秘密密钥汉明重量64) ,P（评估密钥参数），以及实数 \(\sigma\)(3.2)，使得对关联的 RLWE 实例，最佳攻击的复杂度为 \(2^\lambda\)。私钥为 \(\mathbf{s} = (1, s)\)，其中，\(s \in HWT(h),意思为h个±1，其余为0的向量空间\)。生成一个均匀随机的 \(a \in R_{q_L}\)，并计算 \(b = -as + e \mod q_L\)。其中，\(e \in DG(\sigma^2)\)。最后，采样 \(a' \in R_{P \cdot q_L}\) 和 \(e' \in DG(\sigma^2)\)，并计算 \(b' = -as + e' + Ps^2 \mod P \cdot q_L\)。公钥为 \(pk = (b, a)\) 和评估密钥为 \(evk = (b', a') ∈R^2_{P \cdot qL}\)（密钥交换 / 再线性化）。

- **明文编码（Ecd）**：CKKS16 的原始数据是**复数向量**（如机器学习特征、信号数据），需通过编码转换为分圆环R中的多项式（才能用于 RLWE 加密）缩放因子Δ（64），\( m = \sigma^{-1}\left( \lfloor \Delta \cdot \pi^{-1}(z) \rceil_{\sigma(R)} \right) \) 

- **加密**：消息为 \(m \in R\)，公钥为 \(pk = (b, a) \in R_{q_L}^2\)，随机选择 \(v \in ZO(1/2)（作用：掩盖明文，保证语义安全，即相同明文生成不同密文）\) 和噪声 \(e_0, e_1 \in DG(\sigma^2)\)，如下计算密文

  \(\mathbf{c} = (\beta, \alpha) = v(b, a) + (m + e_0, e_1) \mod q_\ell = (vb + m + e_0, va + e_1) \mod q_\ell\)

- **解密**：输入私钥 \(\mathbf{s} = (1, s)\) 和密文 \(\mathbf{c} \in R_{q_\ell}^2\)，如下计算：

  \(\langle \mathbf{c}, \mathbf{s} \rangle \mod q_\ell \\  = (\beta, \alpha)(1, s) \\  = \beta + \alpha s \mod q_\ell \\  = vb + m + e_0 + (va + e_1)s \mod q_\ell \\  = v(-as + e) + m + e_0 + (va + e_1)s \mod q_\ell \\  = m + ve + e_0 + e_1 s\)

  \(\|e\|_\infty^{can} \leq B_{clean}\)（其中 \(B_{clean} = 8\sqrt{2}\sigma N + 6\sigma\sqrt{N} + 16\sigma\sqrt{hN}\)），即噪声e远小于明文m，可视为近似误差。

- **密文解码（Dcd）：**解密输出的是 “明文多项式 + 噪声”（*m*+*e*），需通过解码恢复原始复数向量，$ z = \pi \circ \sigma(\Delta^{-1} \cdot m') $

- **标量与密文乘法**：输入标量 k 和密文 \(\mathbf{c}\)，直接乘

  \(k\mathbf{c} = (k\beta, k\alpha) = kv(b, a) + k(m + e_0, e_1) \mod q_\ell = (kvb + km + ke_0, kva + ke_1) \mod q_\ell\)

- **解密**：

  \(\langle k\mathbf{c}, \mathbf{s} \rangle \mod q_\ell \\  = k\beta + k\alpha s \mod q_\ell \\  = kvb + km + ke_0 + k(va + e_1)s \mod q_\ell \\  = kv(-as + e) + km + ke_0 + k(va + e_1)s \mod q_\ell \\  = km + kve + ke_0 + ke_1 s\)

  解密获得 km。若 \(k = 10000\)，则是统一扩大；若 \(k = 1/10000\) 则是统一缩小。注意：先统一缩小可能与噪声重叠，导致解密出错。通常需先单独放大数据，再统一缩小，以避免与噪声重叠。

- **同态加法**：\(\mathbf{c} + \mathbf{c}' = \big((v + v')b + (m + m') + (e_0 + e_0'),\ (a + a')a + (e_1 + e_1')\big) \mod q_\ell\)

- **解密**：输入私钥 \(\mathbf{s} = (1, s)\) 和密文 \(\mathbf{c} + \mathbf{c}' \in R_{q_\ell}^2\)，计算如下：

  \(\langle (\mathbf{c} + \mathbf{c}'), \mathbf{s} \rangle \mod q_\ell \\  = (\beta + \beta') + (\alpha + \alpha')s \mod q_\ell \\  = (v + v')b + (m + m') + (e_0 + e_0') + (a + a')as + (e_1 + e_1')s \mod q_\ell \\  = (v + v')(-as + e) + (m + m') + (e_0 + e_0') + (a + a')as + (e_1 + e_1')s \mod q_\ell \\  = (m + m') + (v + v')e + (e_0 + e_0') + (e_1 + e_1')s\)

- **同态乘法**：

  \(\mathbf{c} \otimes \mathbf{c}' = (\beta, \alpha)(\beta', \alpha') = (\beta\beta', \beta\alpha', \alpha\beta', \alpha\alpha') = (d_0, d_1, d_2) = (d_0, d_1) + P^{-1}d_2 \cdot evk = (\bar{\beta}, \bar{\alpha})\)

  使用**密钥交换 / 再线性化**技术，将扩展密文 \(\mathbf{c} \otimes \mathbf{c}' = (d_0, d_1, d_2)\) 转换为正常密文 \((\bar{\beta}, \bar{\alpha})\)。

- **解密**：

  - 若为扩展密文 \(\mathbf{c} \otimes \mathbf{c}' = (d_0, d_1, d_2)\)，则使用扩展私钥 \((1, s, s^2)\) 解密；
  - 若为密钥交换 / 再线性化密文 \((\bar{\beta}, \bar{\alpha})\)，则使用正常私钥 \((1, s)\) 解密（通常为该情况，使加密生成的密文与同态计算后的密文不可区分）。

需要注意：当两个密文 \(\mathbf{c}, \mathbf{c}'\) 处于不同级别 \(\ell' < \ell\) 时，需调整更高级别密文的级别以匹配。这可通过简单模约简或者RS过程实现，不过论文中使用的是简单模约化。

**输入与输出**

- 输入：层级$\ell_1$的密文$c \in R_{q_{\ell_1}}^2$（满足$\langle c, sk \rangle \equiv m + e \pmod{q_{\ell_1}}$）；
- 输出：层级$\ell_2$的密文$c' \in R_{q_{\ell_2}}^2$（满足$\langle c', sk \rangle \equiv m + e \pmod{q_{\ell_2}}$）。

**具体操作**

对密文的每个分量（多项式）执行系数级模约简：
$$c' = (c_0 \bmod q_{\ell_2},\ c_1 \bmod q_{\ell_2})$$

其中 $\bmod q_{\ell_2}$表示将多项式的每个系数对$q_{\ell_2}$取模（即若系数为$  a  $，则转换为$a - k \cdot q_{\ell_2}$，使得结果落在$[-q_{\ell_2}/2, q_{\ell_2}/2)$区间内）。

**CKKS16 特点**：消息空间可表示为扩展域 \(\mathcal{C}\) 中的元素。非正式地，消息 m 可嵌入 \(S = R[x]/\langle x^d + 1 \rangle\) 中。由于 \(x^d + 1\) 的根是复数单位根，若将 \(m \in S\) 转换为复数向量，只需在这些复数根上对其求值。第四代方案类似第二代方案，区别在于第四代是近似计算，支持浮点数计算且计算速度显著提高。

##### CKKS16 应用

CKKS16 实现浮点计算：\(1.234 \times 0.689 \times 2.194 \times 0.971 \times 3.323 \times 4.154 \times 0.489 \times 3.772 =?\)

- ChatGPT 4o: 46.03
- Gork 2.0: 45.8
- deepseek: 46.12

逐步计算并保留 2 位小数：\(1.23 \times 0.68 \times 2.19 \times 0.91 \times 3.32 \times 4.15 \times 0.48 \times 3.77 = 41.62\)

逐步计算并保留所有小数：\(1.23 \cdot 0.68 \cdot 2.19 \cdot 0.91 \cdot 3.32 \cdot 4.15 \cdot 0.48 \cdot 3.77 = 41.5594574077313280 \approx 41.56\)

先放大，再缩小：\(12340 \cdot 6890 \cdot 21940 \cdot 9170 \cdot 33230 \cdot 41540 \cdot 4890 \cdot 37720 / 10000^8 = 4.361 \cdot 10^{33} / 10000^8 = 43.61\)

**方法**：先放大，再计算，再缩小最终结果，可获得准确值。

消息 \(1.234\) 扩大 12340，然后加密，再进行同态乘法，之后解密，最后缩小 10000，即可获得 \(1.234\)。加密和解密过程中，噪声对放大的消息影响较小。

**缩减技术**：CKKS16 的密文可乘以常量 \(1/p\)，实现对应明文数据的缩小，用于缩小噪声。

![image-20251124152820957](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251124152820957.png)

**时间复杂度分析**

多项式乘法时间复杂度$O(logk⋅NlogN)$，空间复杂度$O（logk）$

Paterson-Stockmeyer 算法（针对多项式评估）

如果场景是计算单个密文 $ c $ 的多项式值 $P(c) = \sum a_i c^i$（即 $ n $ 个多项式其实是同一个密文的幂），论文提到了更高级的空间换时间策略。

- **原理**：单纯计算 $c^n$ 需要 $\log n$ 深度。但如果要评估一个 $n$ 阶多项式，朴素方法需要 $O(n)$ 次乘法。
- **优化**：论文建议使用 **Paterson-Stockmeyer 算法** 。该算法通过预计算并存储（空间消耗）$x^2, \dots, x^{\sqrt{n}}$ 的幂，将乘法次数从 $O(n)$ 减少到 $O(\sqrt{n})$ 。
- **复杂度收益**：
  - **时间**：乘法数量减少至 $\approx \sqrt{2n}$。
  - **空间**：需要存储 $\approx \sqrt{n}$ 个中间密文。













## 问题

GSW13解密得明文那一步





